// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/document_action.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Symbolic_Pb_PathAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_PathAction.OneOf_Kind? = nil

  var create: Symbolic_Pb_PathAction.Create {
    get {
      if case .create(let v)? = kind {return v}
      return Symbolic_Pb_PathAction.Create()
    }
    set {kind = .create(newValue)}
  }

  var update: Symbolic_Pb_PathAction.Update {
    get {
      if case .update(let v)? = kind {return v}
      return Symbolic_Pb_PathAction.Update()
    }
    set {kind = .update(newValue)}
  }

  var delete: Symbolic_Pb_PathAction.Delete {
    get {
      if case .delete(let v)? = kind {return v}
      return Symbolic_Pb_PathAction.Delete()
    }
    set {kind = .delete(newValue)}
  }

  var move: Symbolic_Pb_PathAction.Move {
    get {
      if case .move(let v)? = kind {return v}
      return Symbolic_Pb_PathAction.Move()
    }
    set {kind = .move(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case create(Symbolic_Pb_PathAction.Create)
    case update(Symbolic_Pb_PathAction.Update)
    case delete(Symbolic_Pb_PathAction.Delete)
    case move(Symbolic_Pb_PathAction.Move)

  }

  struct Create: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var symbolID: Symbolic_Pb_UUID {
      get {return _symbolID ?? Symbolic_Pb_UUID()}
      set {_symbolID = newValue}
    }
    /// Returns true if `symbolID` has been explicitly set.
    var hasSymbolID: Bool {return self._symbolID != nil}
    /// Clears the value of `symbolID`. Subsequent reads from it will return its default value.
    mutating func clearSymbolID() {self._symbolID = nil}

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var path: Symbolic_Pb_Path {
      get {return _path ?? Symbolic_Pb_Path()}
      set {_path = newValue}
    }
    /// Returns true if `path` has been explicitly set.
    var hasPath: Bool {return self._path != nil}
    /// Clears the value of `path`. Subsequent reads from it will return its default value.
    mutating func clearPath() {self._path = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _symbolID: Symbolic_Pb_UUID? = nil
    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
    fileprivate var _path: Symbolic_Pb_Path? = nil
  }

  struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var kind: Symbolic_Pb_PathAction.Update.OneOf_Kind? = nil

    var addEndingNode: Symbolic_Pb_PathAction.Update.AddEndingNode {
      get {
        if case .addEndingNode(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.AddEndingNode()
      }
      set {kind = .addEndingNode(newValue)}
    }

    var splitSegment: Symbolic_Pb_PathAction.Update.SplitSegment {
      get {
        if case .splitSegment(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.SplitSegment()
      }
      set {kind = .splitSegment(newValue)}
    }

    var deleteNodes: Symbolic_Pb_PathAction.Update.DeleteNodes {
      get {
        if case .deleteNodes(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.DeleteNodes()
      }
      set {kind = .deleteNodes(newValue)}
    }

    var updateNode: Symbolic_Pb_PathAction.Update.UpdateNode {
      get {
        if case .updateNode(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.UpdateNode()
      }
      set {kind = .updateNode(newValue)}
    }

    var updateSegment: Symbolic_Pb_PathAction.Update.UpdateSegment {
      get {
        if case .updateSegment(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.UpdateSegment()
      }
      set {kind = .updateSegment(newValue)}
    }

    var moveNodes: Symbolic_Pb_PathAction.Update.MoveNodes {
      get {
        if case .moveNodes(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.MoveNodes()
      }
      set {kind = .moveNodes(newValue)}
    }

    var moveNodeControl: Symbolic_Pb_PathAction.Update.MoveNodeControl {
      get {
        if case .moveNodeControl(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.MoveNodeControl()
      }
      set {kind = .moveNodeControl(newValue)}
    }

    var merge: Symbolic_Pb_PathAction.Update.Merge {
      get {
        if case .merge(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.Merge()
      }
      set {kind = .merge(newValue)}
    }

    var split: Symbolic_Pb_PathAction.Update.Split {
      get {
        if case .split(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.Split()
      }
      set {kind = .split(newValue)}
    }

    var setNodeType: Symbolic_Pb_PathAction.Update.SetNodeType {
      get {
        if case .setNodeType(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.SetNodeType()
      }
      set {kind = .setNodeType(newValue)}
    }

    var setSegmentType: Symbolic_Pb_PathAction.Update.SetSegmentType {
      get {
        if case .setSegmentType(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.SetSegmentType()
      }
      set {kind = .setSegmentType(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
      case addEndingNode(Symbolic_Pb_PathAction.Update.AddEndingNode)
      case splitSegment(Symbolic_Pb_PathAction.Update.SplitSegment)
      case deleteNodes(Symbolic_Pb_PathAction.Update.DeleteNodes)
      case updateNode(Symbolic_Pb_PathAction.Update.UpdateNode)
      case updateSegment(Symbolic_Pb_PathAction.Update.UpdateSegment)
      case moveNodes(Symbolic_Pb_PathAction.Update.MoveNodes)
      case moveNodeControl(Symbolic_Pb_PathAction.Update.MoveNodeControl)
      case merge(Symbolic_Pb_PathAction.Update.Merge)
      case split(Symbolic_Pb_PathAction.Update.Split)
      case setNodeType(Symbolic_Pb_PathAction.Update.SetNodeType)
      case setSegmentType(Symbolic_Pb_PathAction.Update.SetSegmentType)

    }

    struct AddEndingNode: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var endingNodeID: Symbolic_Pb_UUID {
        get {return _endingNodeID ?? Symbolic_Pb_UUID()}
        set {_endingNodeID = newValue}
      }
      /// Returns true if `endingNodeID` has been explicitly set.
      var hasEndingNodeID: Bool {return self._endingNodeID != nil}
      /// Clears the value of `endingNodeID`. Subsequent reads from it will return its default value.
      mutating func clearEndingNodeID() {self._endingNodeID = nil}

      var newNodeID: Symbolic_Pb_UUID {
        get {return _newNodeID ?? Symbolic_Pb_UUID()}
        set {_newNodeID = newValue}
      }
      /// Returns true if `newNodeID` has been explicitly set.
      var hasNewNodeID: Bool {return self._newNodeID != nil}
      /// Clears the value of `newNodeID`. Subsequent reads from it will return its default value.
      mutating func clearNewNodeID() {self._newNodeID = nil}

      var offset: Symbolic_Pb_Vector2 {
        get {return _offset ?? Symbolic_Pb_Vector2()}
        set {_offset = newValue}
      }
      /// Returns true if `offset` has been explicitly set.
      var hasOffset: Bool {return self._offset != nil}
      /// Clears the value of `offset`. Subsequent reads from it will return its default value.
      mutating func clearOffset() {self._offset = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _endingNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _newNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _offset: Symbolic_Pb_Vector2? = nil
    }

    struct SplitSegment: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var fromNodeID: Symbolic_Pb_UUID {
        get {return _fromNodeID ?? Symbolic_Pb_UUID()}
        set {_fromNodeID = newValue}
      }
      /// Returns true if `fromNodeID` has been explicitly set.
      var hasFromNodeID: Bool {return self._fromNodeID != nil}
      /// Clears the value of `fromNodeID`. Subsequent reads from it will return its default value.
      mutating func clearFromNodeID() {self._fromNodeID = nil}

      var paramT: Double = 0

      var newNodeID: Symbolic_Pb_UUID {
        get {return _newNodeID ?? Symbolic_Pb_UUID()}
        set {_newNodeID = newValue}
      }
      /// Returns true if `newNodeID` has been explicitly set.
      var hasNewNodeID: Bool {return self._newNodeID != nil}
      /// Clears the value of `newNodeID`. Subsequent reads from it will return its default value.
      mutating func clearNewNodeID() {self._newNodeID = nil}

      var offset: Symbolic_Pb_Vector2 {
        get {return _offset ?? Symbolic_Pb_Vector2()}
        set {_offset = newValue}
      }
      /// Returns true if `offset` has been explicitly set.
      var hasOffset: Bool {return self._offset != nil}
      /// Clears the value of `offset`. Subsequent reads from it will return its default value.
      mutating func clearOffset() {self._offset = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _fromNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _newNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _offset: Symbolic_Pb_Vector2? = nil
    }

    struct DeleteNodes: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeIds: [Symbolic_Pb_UUID] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct UpdateNode: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeID: Symbolic_Pb_UUID {
        get {return _nodeID ?? Symbolic_Pb_UUID()}
        set {_nodeID = newValue}
      }
      /// Returns true if `nodeID` has been explicitly set.
      var hasNodeID: Bool {return self._nodeID != nil}
      /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
      mutating func clearNodeID() {self._nodeID = nil}

      var node: Symbolic_Pb_PathNode {
        get {return _node ?? Symbolic_Pb_PathNode()}
        set {_node = newValue}
      }
      /// Returns true if `node` has been explicitly set.
      var hasNode: Bool {return self._node != nil}
      /// Clears the value of `node`. Subsequent reads from it will return its default value.
      mutating func clearNode() {self._node = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _node: Symbolic_Pb_PathNode? = nil
    }

    struct UpdateSegment: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var fromNodeID: Symbolic_Pb_UUID {
        get {return _fromNodeID ?? Symbolic_Pb_UUID()}
        set {_fromNodeID = newValue}
      }
      /// Returns true if `fromNodeID` has been explicitly set.
      var hasFromNodeID: Bool {return self._fromNodeID != nil}
      /// Clears the value of `fromNodeID`. Subsequent reads from it will return its default value.
      mutating func clearFromNodeID() {self._fromNodeID = nil}

      var segment: Symbolic_Pb_PathSegment {
        get {return _segment ?? Symbolic_Pb_PathSegment()}
        set {_segment = newValue}
      }
      /// Returns true if `segment` has been explicitly set.
      var hasSegment: Bool {return self._segment != nil}
      /// Clears the value of `segment`. Subsequent reads from it will return its default value.
      mutating func clearSegment() {self._segment = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _fromNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _segment: Symbolic_Pb_PathSegment? = nil
    }

    struct MoveNodes: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeIds: [Symbolic_Pb_UUID] = []

      var offset: Symbolic_Pb_Vector2 {
        get {return _offset ?? Symbolic_Pb_Vector2()}
        set {_offset = newValue}
      }
      /// Returns true if `offset` has been explicitly set.
      var hasOffset: Bool {return self._offset != nil}
      /// Clears the value of `offset`. Subsequent reads from it will return its default value.
      mutating func clearOffset() {self._offset = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _offset: Symbolic_Pb_Vector2? = nil
    }

    struct MoveNodeControl: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeID: Symbolic_Pb_UUID {
        get {return _nodeID ?? Symbolic_Pb_UUID()}
        set {_nodeID = newValue}
      }
      /// Returns true if `nodeID` has been explicitly set.
      var hasNodeID: Bool {return self._nodeID != nil}
      /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
      mutating func clearNodeID() {self._nodeID = nil}

      var controlType: Symbolic_Pb_PathNodeControlType = .cubicIn

      var offset: Symbolic_Pb_Vector2 {
        get {return _offset ?? Symbolic_Pb_Vector2()}
        set {_offset = newValue}
      }
      /// Returns true if `offset` has been explicitly set.
      var hasOffset: Bool {return self._offset != nil}
      /// Clears the value of `offset`. Subsequent reads from it will return its default value.
      mutating func clearOffset() {self._offset = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _offset: Symbolic_Pb_Vector2? = nil
    }

    struct Merge: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var endingNodeID: Symbolic_Pb_UUID {
        get {return _endingNodeID ?? Symbolic_Pb_UUID()}
        set {_endingNodeID = newValue}
      }
      /// Returns true if `endingNodeID` has been explicitly set.
      var hasEndingNodeID: Bool {return self._endingNodeID != nil}
      /// Clears the value of `endingNodeID`. Subsequent reads from it will return its default value.
      mutating func clearEndingNodeID() {self._endingNodeID = nil}

      var mergedPathID: Symbolic_Pb_UUID {
        get {return _mergedPathID ?? Symbolic_Pb_UUID()}
        set {_mergedPathID = newValue}
      }
      /// Returns true if `mergedPathID` has been explicitly set.
      var hasMergedPathID: Bool {return self._mergedPathID != nil}
      /// Clears the value of `mergedPathID`. Subsequent reads from it will return its default value.
      mutating func clearMergedPathID() {self._mergedPathID = nil}

      var mergedEndingNodeID: Symbolic_Pb_UUID {
        get {return _mergedEndingNodeID ?? Symbolic_Pb_UUID()}
        set {_mergedEndingNodeID = newValue}
      }
      /// Returns true if `mergedEndingNodeID` has been explicitly set.
      var hasMergedEndingNodeID: Bool {return self._mergedEndingNodeID != nil}
      /// Clears the value of `mergedEndingNodeID`. Subsequent reads from it will return its default value.
      mutating func clearMergedEndingNodeID() {self._mergedEndingNodeID = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _endingNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _mergedPathID: Symbolic_Pb_UUID? = nil
      fileprivate var _mergedEndingNodeID: Symbolic_Pb_UUID? = nil
    }

    struct Split: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeID: Symbolic_Pb_UUID {
        get {return _nodeID ?? Symbolic_Pb_UUID()}
        set {_nodeID = newValue}
      }
      /// Returns true if `nodeID` has been explicitly set.
      var hasNodeID: Bool {return self._nodeID != nil}
      /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
      mutating func clearNodeID() {self._nodeID = nil}

      var newPathID: Symbolic_Pb_UUID {
        get {return _newPathID ?? Symbolic_Pb_UUID()}
        set {_newPathID = newValue}
      }
      /// Returns true if `newPathID` has been explicitly set.
      var hasNewPathID: Bool {return self._newPathID != nil}
      /// Clears the value of `newPathID`. Subsequent reads from it will return its default value.
      mutating func clearNewPathID() {self._newPathID = nil}

      var newNodeID: Symbolic_Pb_UUID {
        get {return _newNodeID ?? Symbolic_Pb_UUID()}
        set {_newNodeID = newValue}
      }
      /// Returns true if `newNodeID` has been explicitly set.
      var hasNewNodeID: Bool {return self._newNodeID != nil}
      /// Clears the value of `newNodeID`. Subsequent reads from it will return its default value.
      mutating func clearNewNodeID() {self._newNodeID = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _newPathID: Symbolic_Pb_UUID? = nil
      fileprivate var _newNodeID: Symbolic_Pb_UUID? = nil
    }

    struct SetNodeType: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeIds: [Symbolic_Pb_UUID] = []

      var nodeType: Symbolic_Pb_PathNodeType {
        get {return _nodeType ?? .corner}
        set {_nodeType = newValue}
      }
      /// Returns true if `nodeType` has been explicitly set.
      var hasNodeType: Bool {return self._nodeType != nil}
      /// Clears the value of `nodeType`. Subsequent reads from it will return its default value.
      mutating func clearNodeType() {self._nodeType = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeType: Symbolic_Pb_PathNodeType? = nil
    }

    struct SetSegmentType: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var fromNodeIds: [Symbolic_Pb_UUID] = []

      var segmentType: Symbolic_Pb_PathSegmentType {
        get {return _segmentType ?? .cubic}
        set {_segmentType = newValue}
      }
      /// Returns true if `segmentType` has been explicitly set.
      var hasSegmentType: Bool {return self._segmentType != nil}
      /// Clears the value of `segmentType`. Subsequent reads from it will return its default value.
      mutating func clearSegmentType() {self._segmentType = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _segmentType: Symbolic_Pb_PathSegmentType? = nil
    }

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
  }

  struct Delete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathIds: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Move: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathIds: [Symbolic_Pb_UUID] = []

    var offset: Symbolic_Pb_Vector2 {
      get {return _offset ?? Symbolic_Pb_Vector2()}
      set {_offset = newValue}
    }
    /// Returns true if `offset` has been explicitly set.
    var hasOffset: Bool {return self._offset != nil}
    /// Clears the value of `offset`. Subsequent reads from it will return its default value.
    mutating func clearOffset() {self._offset = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _offset: Symbolic_Pb_Vector2? = nil
  }

  init() {}
}

struct Symbolic_Pb_SymbolAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_SymbolAction.OneOf_Kind? = nil

  var create: Symbolic_Pb_SymbolAction.Create {
    get {
      if case .create(let v)? = kind {return v}
      return Symbolic_Pb_SymbolAction.Create()
    }
    set {kind = .create(newValue)}
  }

  var resize: Symbolic_Pb_SymbolAction.Resize {
    get {
      if case .resize(let v)? = kind {return v}
      return Symbolic_Pb_SymbolAction.Resize()
    }
    set {kind = .resize(newValue)}
  }

  var setGrid: Symbolic_Pb_SymbolAction.SetGrid {
    get {
      if case .setGrid(let v)? = kind {return v}
      return Symbolic_Pb_SymbolAction.SetGrid()
    }
    set {kind = .setGrid(newValue)}
  }

  var delete: Symbolic_Pb_SymbolAction.Delete {
    get {
      if case .delete(let v)? = kind {return v}
      return Symbolic_Pb_SymbolAction.Delete()
    }
    set {kind = .delete(newValue)}
  }

  var move: Symbolic_Pb_SymbolAction.Move {
    get {
      if case .move(let v)? = kind {return v}
      return Symbolic_Pb_SymbolAction.Move()
    }
    set {kind = .move(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case create(Symbolic_Pb_SymbolAction.Create)
    case resize(Symbolic_Pb_SymbolAction.Resize)
    case setGrid(Symbolic_Pb_SymbolAction.SetGrid)
    case delete(Symbolic_Pb_SymbolAction.Delete)
    case move(Symbolic_Pb_SymbolAction.Move)

  }

  struct Create: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var symbolID: Symbolic_Pb_UUID {
      get {return _symbolID ?? Symbolic_Pb_UUID()}
      set {_symbolID = newValue}
    }
    /// Returns true if `symbolID` has been explicitly set.
    var hasSymbolID: Bool {return self._symbolID != nil}
    /// Clears the value of `symbolID`. Subsequent reads from it will return its default value.
    mutating func clearSymbolID() {self._symbolID = nil}

    var origin: Symbolic_Pb_Point2 {
      get {return _origin ?? Symbolic_Pb_Point2()}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var size: Symbolic_Pb_Size2 {
      get {return _size ?? Symbolic_Pb_Size2()}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating func clearSize() {self._size = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _symbolID: Symbolic_Pb_UUID? = nil
    fileprivate var _origin: Symbolic_Pb_Point2? = nil
    fileprivate var _size: Symbolic_Pb_Size2? = nil
  }

  struct Resize: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var symbolID: Symbolic_Pb_UUID {
      get {return _symbolID ?? Symbolic_Pb_UUID()}
      set {_symbolID = newValue}
    }
    /// Returns true if `symbolID` has been explicitly set.
    var hasSymbolID: Bool {return self._symbolID != nil}
    /// Clears the value of `symbolID`. Subsequent reads from it will return its default value.
    mutating func clearSymbolID() {self._symbolID = nil}

    var align: Symbolic_Pb_PlaneInnerAlign = .topLeading

    var offset: Symbolic_Pb_Vector2 {
      get {return _offset ?? Symbolic_Pb_Vector2()}
      set {_offset = newValue}
    }
    /// Returns true if `offset` has been explicitly set.
    var hasOffset: Bool {return self._offset != nil}
    /// Clears the value of `offset`. Subsequent reads from it will return its default value.
    mutating func clearOffset() {self._offset = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _symbolID: Symbolic_Pb_UUID? = nil
    fileprivate var _offset: Symbolic_Pb_Vector2? = nil
  }

  struct SetGrid: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var symbolID: Symbolic_Pb_UUID {
      get {return _symbolID ?? Symbolic_Pb_UUID()}
      set {_symbolID = newValue}
    }
    /// Returns true if `symbolID` has been explicitly set.
    var hasSymbolID: Bool {return self._symbolID != nil}
    /// Clears the value of `symbolID`. Subsequent reads from it will return its default value.
    mutating func clearSymbolID() {self._symbolID = nil}

    var index: UInt32 = 0

    var grid: Symbolic_Pb_Grid {
      get {return _grid ?? Symbolic_Pb_Grid()}
      set {_grid = newValue}
    }
    /// Returns true if `grid` has been explicitly set.
    var hasGrid: Bool {return self._grid != nil}
    /// Clears the value of `grid`. Subsequent reads from it will return its default value.
    mutating func clearGrid() {self._grid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _symbolID: Symbolic_Pb_UUID? = nil
    fileprivate var _grid: Symbolic_Pb_Grid? = nil
  }

  struct Delete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var symbolIds: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Move: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var symbolIds: [Symbolic_Pb_UUID] = []

    var offset: Symbolic_Pb_Vector2 {
      get {return _offset ?? Symbolic_Pb_Vector2()}
      set {_offset = newValue}
    }
    /// Returns true if `offset` has been explicitly set.
    var hasOffset: Bool {return self._offset != nil}
    /// Clears the value of `offset`. Subsequent reads from it will return its default value.
    mutating func clearOffset() {self._offset = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _offset: Symbolic_Pb_Vector2? = nil
  }

  init() {}
}

struct Symbolic_Pb_ItemAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_ItemAction.OneOf_Kind? = nil

  var group: Symbolic_Pb_ItemAction.Group {
    get {
      if case .group(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction.Group()
    }
    set {kind = .group(newValue)}
  }

  var ungroup: Symbolic_Pb_ItemAction.Ungroup {
    get {
      if case .ungroup(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction.Ungroup()
    }
    set {kind = .ungroup(newValue)}
  }

  var reorder: Symbolic_Pb_ItemAction.Reorder {
    get {
      if case .reorder(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction.Reorder()
    }
    set {kind = .reorder(newValue)}
  }

  var setName: Symbolic_Pb_ItemAction.SetName {
    get {
      if case .setName(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction.SetName()
    }
    set {kind = .setName(newValue)}
  }

  var setLocked: Symbolic_Pb_ItemAction.SetLocked {
    get {
      if case .setLocked(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction.SetLocked()
    }
    set {kind = .setLocked(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case group(Symbolic_Pb_ItemAction.Group)
    case ungroup(Symbolic_Pb_ItemAction.Ungroup)
    case reorder(Symbolic_Pb_ItemAction.Reorder)
    case setName(Symbolic_Pb_ItemAction.SetName)
    case setLocked(Symbolic_Pb_ItemAction.SetLocked)

  }

  struct Group: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupID: Symbolic_Pb_UUID {
      get {return _groupID ?? Symbolic_Pb_UUID()}
      set {_groupID = newValue}
    }
    /// Returns true if `groupID` has been explicitly set.
    var hasGroupID: Bool {return self._groupID != nil}
    /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
    mutating func clearGroupID() {self._groupID = nil}

    var members: [Symbolic_Pb_UUID] = []

    var inSymbolID: Symbolic_Pb_UUID {
      get {return _inSymbolID ?? Symbolic_Pb_UUID()}
      set {_inSymbolID = newValue}
    }
    /// Returns true if `inSymbolID` has been explicitly set.
    var hasInSymbolID: Bool {return self._inSymbolID != nil}
    /// Clears the value of `inSymbolID`. Subsequent reads from it will return its default value.
    mutating func clearInSymbolID() {self._inSymbolID = nil}

    var inGroupID: Symbolic_Pb_UUID {
      get {return _inGroupID ?? Symbolic_Pb_UUID()}
      set {_inGroupID = newValue}
    }
    /// Returns true if `inGroupID` has been explicitly set.
    var hasInGroupID: Bool {return self._inGroupID != nil}
    /// Clears the value of `inGroupID`. Subsequent reads from it will return its default value.
    mutating func clearInGroupID() {self._inGroupID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _groupID: Symbolic_Pb_UUID? = nil
    fileprivate var _inSymbolID: Symbolic_Pb_UUID? = nil
    fileprivate var _inGroupID: Symbolic_Pb_UUID? = nil
  }

  struct Ungroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupIds: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Reorder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var itemID: Symbolic_Pb_UUID {
      get {return _itemID ?? Symbolic_Pb_UUID()}
      set {_itemID = newValue}
    }
    /// Returns true if `itemID` has been explicitly set.
    var hasItemID: Bool {return self._itemID != nil}
    /// Clears the value of `itemID`. Subsequent reads from it will return its default value.
    mutating func clearItemID() {self._itemID = nil}

    var toItemID: Symbolic_Pb_UUID {
      get {return _toItemID ?? Symbolic_Pb_UUID()}
      set {_toItemID = newValue}
    }
    /// Returns true if `toItemID` has been explicitly set.
    var hasToItemID: Bool {return self._toItemID != nil}
    /// Clears the value of `toItemID`. Subsequent reads from it will return its default value.
    mutating func clearToItemID() {self._toItemID = nil}

    var isAfter: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _itemID: Symbolic_Pb_UUID? = nil
    fileprivate var _toItemID: Symbolic_Pb_UUID? = nil
  }

  struct SetName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var itemID: Symbolic_Pb_UUID {
      get {return _itemID ?? Symbolic_Pb_UUID()}
      set {_itemID = newValue}
    }
    /// Returns true if `itemID` has been explicitly set.
    var hasItemID: Bool {return self._itemID != nil}
    /// Clears the value of `itemID`. Subsequent reads from it will return its default value.
    mutating func clearItemID() {self._itemID = nil}

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _itemID: Symbolic_Pb_UUID? = nil
    fileprivate var _name: String? = nil
  }

  struct SetLocked: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var itemIds: [Symbolic_Pb_UUID] = []

    var locked: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Symbolic_Pb_WorldAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_WorldAction.OneOf_Kind? = nil

  var setSymbolIds: Symbolic_Pb_WorldAction.SetSymbolIds {
    get {
      if case .setSymbolIds(let v)? = kind {return v}
      return Symbolic_Pb_WorldAction.SetSymbolIds()
    }
    set {kind = .setSymbolIds(newValue)}
  }

  var setGrid: Symbolic_Pb_WorldAction.SetGrid {
    get {
      if case .setGrid(let v)? = kind {return v}
      return Symbolic_Pb_WorldAction.SetGrid()
    }
    set {kind = .setGrid(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case setSymbolIds(Symbolic_Pb_WorldAction.SetSymbolIds)
    case setGrid(Symbolic_Pb_WorldAction.SetGrid)

  }

  struct SetSymbolIds: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var symbolIds: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SetGrid: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var grid: Symbolic_Pb_Grid {
      get {return _grid ?? Symbolic_Pb_Grid()}
      set {_grid = newValue}
    }
    /// Returns true if `grid` has been explicitly set.
    var hasGrid: Bool {return self._grid != nil}
    /// Clears the value of `grid`. Subsequent reads from it will return its default value.
    mutating func clearGrid() {self._grid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _grid: Symbolic_Pb_Grid? = nil
  }

  init() {}
}

struct Symbolic_Pb_DocumentAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_DocumentAction.OneOf_Kind? = nil

  var pathAction: Symbolic_Pb_PathAction {
    get {
      if case .pathAction(let v)? = kind {return v}
      return Symbolic_Pb_PathAction()
    }
    set {kind = .pathAction(newValue)}
  }

  var symbolAction: Symbolic_Pb_SymbolAction {
    get {
      if case .symbolAction(let v)? = kind {return v}
      return Symbolic_Pb_SymbolAction()
    }
    set {kind = .symbolAction(newValue)}
  }

  var itemAction: Symbolic_Pb_ItemAction {
    get {
      if case .itemAction(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction()
    }
    set {kind = .itemAction(newValue)}
  }

  var worldAction: Symbolic_Pb_WorldAction {
    get {
      if case .worldAction(let v)? = kind {return v}
      return Symbolic_Pb_WorldAction()
    }
    set {kind = .worldAction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case pathAction(Symbolic_Pb_PathAction)
    case symbolAction(Symbolic_Pb_SymbolAction)
    case itemAction(Symbolic_Pb_ItemAction)
    case worldAction(Symbolic_Pb_WorldAction)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "symbolic.pb"

extension Symbolic_Pb_PathAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "create"),
    102: .same(proto: "update"),
    201: .same(proto: "delete"),
    202: .same(proto: "move"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathAction.Create?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .create(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathAction.Update?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .update(v)
        }
      }()
      case 201: try {
        var v: Symbolic_Pb_PathAction.Delete?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .delete(v)
        }
      }()
      case 202: try {
        var v: Symbolic_Pb_PathAction.Move?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .move(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .move(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .create?: try {
      guard case .create(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .update?: try {
      guard case .update(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
    }()
    case .move?: try {
      guard case .move(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 202)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction, rhs: Symbolic_Pb_PathAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.protoMessageName + ".Create"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symbol_id"),
    2: .standard(proto: "path_id"),
    3: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._symbolID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._symbolID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Create, rhs: Symbolic_Pb_PathAction.Create) -> Bool {
    if lhs._symbolID != rhs._symbolID {return false}
    if lhs._pathID != rhs._pathID {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.protoMessageName + ".Update"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    101: .standard(proto: "add_ending_node"),
    102: .standard(proto: "split_segment"),
    103: .standard(proto: "delete_nodes"),
    104: .standard(proto: "update_node"),
    105: .standard(proto: "update_segment"),
    106: .standard(proto: "move_nodes"),
    107: .standard(proto: "move_node_control"),
    108: .same(proto: "merge"),
    109: .same(proto: "split"),
    201: .standard(proto: "set_node_type"),
    202: .standard(proto: "set_segment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 101: try {
        var v: Symbolic_Pb_PathAction.Update.AddEndingNode?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .addEndingNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .addEndingNode(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathAction.Update.SplitSegment?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .splitSegment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .splitSegment(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathAction.Update.DeleteNodes?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .deleteNodes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .deleteNodes(v)
        }
      }()
      case 104: try {
        var v: Symbolic_Pb_PathAction.Update.UpdateNode?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .updateNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .updateNode(v)
        }
      }()
      case 105: try {
        var v: Symbolic_Pb_PathAction.Update.UpdateSegment?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .updateSegment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .updateSegment(v)
        }
      }()
      case 106: try {
        var v: Symbolic_Pb_PathAction.Update.MoveNodes?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .moveNodes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .moveNodes(v)
        }
      }()
      case 107: try {
        var v: Symbolic_Pb_PathAction.Update.MoveNodeControl?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .moveNodeControl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .moveNodeControl(v)
        }
      }()
      case 108: try {
        var v: Symbolic_Pb_PathAction.Update.Merge?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .merge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .merge(v)
        }
      }()
      case 109: try {
        var v: Symbolic_Pb_PathAction.Update.Split?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .split(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .split(v)
        }
      }()
      case 201: try {
        var v: Symbolic_Pb_PathAction.Update.SetNodeType?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setNodeType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setNodeType(v)
        }
      }()
      case 202: try {
        var v: Symbolic_Pb_PathAction.Update.SetSegmentType?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setSegmentType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setSegmentType(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.kind {
    case .addEndingNode?: try {
      guard case .addEndingNode(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .splitSegment?: try {
      guard case .splitSegment(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .deleteNodes?: try {
      guard case .deleteNodes(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .updateNode?: try {
      guard case .updateNode(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .updateSegment?: try {
      guard case .updateSegment(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .moveNodes?: try {
      guard case .moveNodes(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .moveNodeControl?: try {
      guard case .moveNodeControl(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .merge?: try {
      guard case .merge(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .split?: try {
      guard case .split(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .setNodeType?: try {
      guard case .setNodeType(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
    }()
    case .setSegmentType?: try {
      guard case .setSegmentType(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 202)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update, rhs: Symbolic_Pb_PathAction.Update) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.AddEndingNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".AddEndingNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ending_node_id"),
    2: .standard(proto: "new_node_id"),
    3: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endingNodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newNodeID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.AddEndingNode, rhs: Symbolic_Pb_PathAction.Update.AddEndingNode) -> Bool {
    if lhs._endingNodeID != rhs._endingNodeID {return false}
    if lhs._newNodeID != rhs._newNodeID {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.SplitSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".SplitSegment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node_id"),
    2: .same(proto: "paramT"),
    3: .standard(proto: "new_node_id"),
    4: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fromNodeID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.paramT) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newNodeID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fromNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.paramT.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.paramT, fieldNumber: 2)
    }
    try { if let v = self._newNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.SplitSegment, rhs: Symbolic_Pb_PathAction.Update.SplitSegment) -> Bool {
    if lhs._fromNodeID != rhs._fromNodeID {return false}
    if lhs.paramT != rhs.paramT {return false}
    if lhs._newNodeID != rhs._newNodeID {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.DeleteNodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".DeleteNodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.DeleteNodes, rhs: Symbolic_Pb_PathAction.Update.DeleteNodes) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.UpdateNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".UpdateNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.UpdateNode, rhs: Symbolic_Pb_PathAction.Update.UpdateNode) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.UpdateSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".UpdateSegment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node_id"),
    2: .same(proto: "segment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fromNodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._segment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fromNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._segment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.UpdateSegment, rhs: Symbolic_Pb_PathAction.Update.UpdateSegment) -> Bool {
    if lhs._fromNodeID != rhs._fromNodeID {return false}
    if lhs._segment != rhs._segment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.MoveNodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".MoveNodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
    2: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.MoveNodes, rhs: Symbolic_Pb_PathAction.Update.MoveNodes) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.MoveNodeControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".MoveNodeControl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "control_type"),
    3: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.controlType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.controlType != .cubicIn {
      try visitor.visitSingularEnumField(value: self.controlType, fieldNumber: 2)
    }
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.MoveNodeControl, rhs: Symbolic_Pb_PathAction.Update.MoveNodeControl) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs.controlType != rhs.controlType {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.Merge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".Merge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ending_node_id"),
    2: .standard(proto: "merged_path_id"),
    3: .standard(proto: "merged_ending_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endingNodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mergedPathID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mergedEndingNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mergedPathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mergedEndingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.Merge, rhs: Symbolic_Pb_PathAction.Update.Merge) -> Bool {
    if lhs._endingNodeID != rhs._endingNodeID {return false}
    if lhs._mergedPathID != rhs._mergedPathID {return false}
    if lhs._mergedEndingNodeID != rhs._mergedEndingNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.Split: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".Split"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "new_path_id"),
    3: .standard(proto: "new_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newPathID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newPathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.Split, rhs: Symbolic_Pb_PathAction.Update.Split) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._newPathID != rhs._newPathID {return false}
    if lhs._newNodeID != rhs._newNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.SetNodeType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".SetNodeType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
    2: .standard(proto: "node_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._nodeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    try { if let v = self._nodeType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.SetNodeType, rhs: Symbolic_Pb_PathAction.Update.SetNodeType) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs._nodeType != rhs._nodeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.SetSegmentType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".SetSegmentType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node_ids"),
    2: .standard(proto: "segment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fromNodeIds) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._segmentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fromNodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fromNodeIds, fieldNumber: 1)
    }
    try { if let v = self._segmentType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.SetSegmentType, rhs: Symbolic_Pb_PathAction.Update.SetSegmentType) -> Bool {
    if lhs.fromNodeIds != rhs.fromNodeIds {return false}
    if lhs._segmentType != rhs._segmentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.protoMessageName + ".Delete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pathIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Delete, rhs: Symbolic_Pb_PathAction.Delete) -> Bool {
    if lhs.pathIds != rhs.pathIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.protoMessageName + ".Move"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_ids"),
    2: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pathIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pathIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathIds, fieldNumber: 1)
    }
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Move, rhs: Symbolic_Pb_PathAction.Move) -> Bool {
    if lhs.pathIds != rhs.pathIds {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SymbolAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "create"),
    102: .same(proto: "resize"),
    103: .standard(proto: "set_grid"),
    201: .same(proto: "delete"),
    202: .same(proto: "move"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_SymbolAction.Create?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .create(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_SymbolAction.Resize?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .resize(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .resize(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_SymbolAction.SetGrid?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setGrid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setGrid(v)
        }
      }()
      case 201: try {
        var v: Symbolic_Pb_SymbolAction.Delete?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .delete(v)
        }
      }()
      case 202: try {
        var v: Symbolic_Pb_SymbolAction.Move?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .move(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .move(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .create?: try {
      guard case .create(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .resize?: try {
      guard case .resize(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .setGrid?: try {
      guard case .setGrid(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
    }()
    case .move?: try {
      guard case .move(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 202)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolAction, rhs: Symbolic_Pb_SymbolAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolAction.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolAction.protoMessageName + ".Create"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symbol_id"),
    2: .same(proto: "origin"),
    3: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._symbolID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._symbolID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolAction.Create, rhs: Symbolic_Pb_SymbolAction.Create) -> Bool {
    if lhs._symbolID != rhs._symbolID {return false}
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolAction.Resize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolAction.protoMessageName + ".Resize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symbol_id"),
    2: .same(proto: "align"),
    3: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._symbolID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.align) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._symbolID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.align != .topLeading {
      try visitor.visitSingularEnumField(value: self.align, fieldNumber: 2)
    }
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolAction.Resize, rhs: Symbolic_Pb_SymbolAction.Resize) -> Bool {
    if lhs._symbolID != rhs._symbolID {return false}
    if lhs.align != rhs.align {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolAction.SetGrid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolAction.protoMessageName + ".SetGrid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symbol_id"),
    2: .same(proto: "index"),
    3: .same(proto: "grid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._symbolID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._grid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._symbolID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    try { if let v = self._grid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolAction.SetGrid, rhs: Symbolic_Pb_SymbolAction.SetGrid) -> Bool {
    if lhs._symbolID != rhs._symbolID {return false}
    if lhs.index != rhs.index {return false}
    if lhs._grid != rhs._grid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolAction.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolAction.protoMessageName + ".Delete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symbol_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.symbolIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbolIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.symbolIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolAction.Delete, rhs: Symbolic_Pb_SymbolAction.Delete) -> Bool {
    if lhs.symbolIds != rhs.symbolIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolAction.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolAction.protoMessageName + ".Move"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symbol_ids"),
    2: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.symbolIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.symbolIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.symbolIds, fieldNumber: 1)
    }
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolAction.Move, rhs: Symbolic_Pb_SymbolAction.Move) -> Bool {
    if lhs.symbolIds != rhs.symbolIds {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ItemAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "group"),
    102: .same(proto: "ungroup"),
    103: .same(proto: "reorder"),
    201: .standard(proto: "set_name"),
    202: .standard(proto: "set_locked"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_ItemAction.Group?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .group(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .group(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_ItemAction.Ungroup?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .ungroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .ungroup(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_ItemAction.Reorder?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .reorder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .reorder(v)
        }
      }()
      case 201: try {
        var v: Symbolic_Pb_ItemAction.SetName?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setName(v)
        }
      }()
      case 202: try {
        var v: Symbolic_Pb_ItemAction.SetLocked?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setLocked(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setLocked(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .group?: try {
      guard case .group(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .ungroup?: try {
      guard case .ungroup(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .reorder?: try {
      guard case .reorder(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .setName?: try {
      guard case .setName(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
    }()
    case .setLocked?: try {
      guard case .setLocked(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 202)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction, rhs: Symbolic_Pb_ItemAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemAction.Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemAction.protoMessageName + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "members"),
    3: .standard(proto: "in_symbol_id"),
    4: .standard(proto: "in_group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inSymbolID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._inGroupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try { if let v = self._inSymbolID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._inGroupID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction.Group, rhs: Symbolic_Pb_ItemAction.Group) -> Bool {
    if lhs._groupID != rhs._groupID {return false}
    if lhs.members != rhs.members {return false}
    if lhs._inSymbolID != rhs._inSymbolID {return false}
    if lhs._inGroupID != rhs._inGroupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemAction.Ungroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemAction.protoMessageName + ".Ungroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction.Ungroup, rhs: Symbolic_Pb_ItemAction.Ungroup) -> Bool {
    if lhs.groupIds != rhs.groupIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemAction.Reorder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemAction.protoMessageName + ".Reorder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_id"),
    2: .standard(proto: "to_item_id"),
    3: .standard(proto: "is_after"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._itemID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._toItemID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isAfter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._itemID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._toItemID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isAfter != false {
      try visitor.visitSingularBoolField(value: self.isAfter, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction.Reorder, rhs: Symbolic_Pb_ItemAction.Reorder) -> Bool {
    if lhs._itemID != rhs._itemID {return false}
    if lhs._toItemID != rhs._toItemID {return false}
    if lhs.isAfter != rhs.isAfter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemAction.SetName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemAction.protoMessageName + ".SetName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_id"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._itemID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._itemID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction.SetName, rhs: Symbolic_Pb_ItemAction.SetName) -> Bool {
    if lhs._itemID != rhs._itemID {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemAction.SetLocked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemAction.protoMessageName + ".SetLocked"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "item_ids"),
    2: .same(proto: "locked"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.itemIds) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.locked) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.itemIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.itemIds, fieldNumber: 1)
    }
    if self.locked != false {
      try visitor.visitSingularBoolField(value: self.locked, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction.SetLocked, rhs: Symbolic_Pb_ItemAction.SetLocked) -> Bool {
    if lhs.itemIds != rhs.itemIds {return false}
    if lhs.locked != rhs.locked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_WorldAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WorldAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .standard(proto: "set_symbol_ids"),
    102: .standard(proto: "set_grid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_WorldAction.SetSymbolIds?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setSymbolIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setSymbolIds(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_WorldAction.SetGrid?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setGrid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setGrid(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .setSymbolIds?: try {
      guard case .setSymbolIds(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .setGrid?: try {
      guard case .setGrid(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_WorldAction, rhs: Symbolic_Pb_WorldAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_WorldAction.SetSymbolIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_WorldAction.protoMessageName + ".SetSymbolIds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symbol_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.symbolIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbolIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.symbolIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_WorldAction.SetSymbolIds, rhs: Symbolic_Pb_WorldAction.SetSymbolIds) -> Bool {
    if lhs.symbolIds != rhs.symbolIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_WorldAction.SetGrid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_WorldAction.protoMessageName + ".SetGrid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "grid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._grid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._grid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_WorldAction.SetGrid, rhs: Symbolic_Pb_WorldAction.SetGrid) -> Bool {
    if lhs._grid != rhs._grid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_DocumentAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .standard(proto: "path_action"),
    102: .standard(proto: "symbol_action"),
    103: .standard(proto: "item_action"),
    104: .standard(proto: "world_action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathAction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .pathAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .pathAction(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_SymbolAction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .symbolAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .symbolAction(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_ItemAction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .itemAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .itemAction(v)
        }
      }()
      case 104: try {
        var v: Symbolic_Pb_WorldAction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .worldAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .worldAction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .pathAction?: try {
      guard case .pathAction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .symbolAction?: try {
      guard case .symbolAction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .itemAction?: try {
      guard case .itemAction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .worldAction?: try {
      guard case .worldAction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_DocumentAction, rhs: Symbolic_Pb_DocumentAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
