// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/document_event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Symbolic_Pb_PathEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pathIds: [Symbolic_Pb_UUID] = []

  var kinds: [Symbolic_Pb_PathEvent.Kind] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Create: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var path: Symbolic_Pb_Path {
      get {return _path ?? Symbolic_Pb_Path()}
      set {_path = newValue}
    }
    /// Returns true if `path` has been explicitly set.
    var hasPath: Bool {return self._path != nil}
    /// Clears the value of `path`. Subsequent reads from it will return its default value.
    mutating func clearPath() {self._path = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _path: Symbolic_Pb_Path? = nil
  }

  struct CreateNode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var prevNodeID: Symbolic_Pb_UUID {
      get {return _prevNodeID ?? Symbolic_Pb_UUID()}
      set {_prevNodeID = newValue}
    }
    /// Returns true if `prevNodeID` has been explicitly set.
    var hasPrevNodeID: Bool {return self._prevNodeID != nil}
    /// Clears the value of `prevNodeID`. Subsequent reads from it will return its default value.
    mutating func clearPrevNodeID() {self._prevNodeID = nil}

    var nodeID: Symbolic_Pb_UUID {
      get {return _nodeID ?? Symbolic_Pb_UUID()}
      set {_nodeID = newValue}
    }
    /// Returns true if `nodeID` has been explicitly set.
    var hasNodeID: Bool {return self._nodeID != nil}
    /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
    mutating func clearNodeID() {self._nodeID = nil}

    var node: Symbolic_Pb_PathNode {
      get {return _node ?? Symbolic_Pb_PathNode()}
      set {_node = newValue}
    }
    /// Returns true if `node` has been explicitly set.
    var hasNode: Bool {return self._node != nil}
    /// Clears the value of `node`. Subsequent reads from it will return its default value.
    mutating func clearNode() {self._node = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _prevNodeID: Symbolic_Pb_UUID? = nil
    fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
    fileprivate var _node: Symbolic_Pb_PathNode? = nil
  }

  struct UpdateNode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodeID: Symbolic_Pb_UUID {
      get {return _nodeID ?? Symbolic_Pb_UUID()}
      set {_nodeID = newValue}
    }
    /// Returns true if `nodeID` has been explicitly set.
    var hasNodeID: Bool {return self._nodeID != nil}
    /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
    mutating func clearNodeID() {self._nodeID = nil}

    var node: Symbolic_Pb_PathNode {
      get {return _node ?? Symbolic_Pb_PathNode()}
      set {_node = newValue}
    }
    /// Returns true if `node` has been explicitly set.
    var hasNode: Bool {return self._node != nil}
    /// Clears the value of `node`. Subsequent reads from it will return its default value.
    mutating func clearNode() {self._node = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
    fileprivate var _node: Symbolic_Pb_PathNode? = nil
  }

  struct DeleteNode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodeIds: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Merge: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var endingNodeID: Symbolic_Pb_UUID {
      get {return _endingNodeID ?? Symbolic_Pb_UUID()}
      set {_endingNodeID = newValue}
    }
    /// Returns true if `endingNodeID` has been explicitly set.
    var hasEndingNodeID: Bool {return self._endingNodeID != nil}
    /// Clears the value of `endingNodeID`. Subsequent reads from it will return its default value.
    mutating func clearEndingNodeID() {self._endingNodeID = nil}

    var mergedPathID: Symbolic_Pb_UUID {
      get {return _mergedPathID ?? Symbolic_Pb_UUID()}
      set {_mergedPathID = newValue}
    }
    /// Returns true if `mergedPathID` has been explicitly set.
    var hasMergedPathID: Bool {return self._mergedPathID != nil}
    /// Clears the value of `mergedPathID`. Subsequent reads from it will return its default value.
    mutating func clearMergedPathID() {self._mergedPathID = nil}

    var mergedEndingNodeID: Symbolic_Pb_UUID {
      get {return _mergedEndingNodeID ?? Symbolic_Pb_UUID()}
      set {_mergedEndingNodeID = newValue}
    }
    /// Returns true if `mergedEndingNodeID` has been explicitly set.
    var hasMergedEndingNodeID: Bool {return self._mergedEndingNodeID != nil}
    /// Clears the value of `mergedEndingNodeID`. Subsequent reads from it will return its default value.
    mutating func clearMergedEndingNodeID() {self._mergedEndingNodeID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _endingNodeID: Symbolic_Pb_UUID? = nil
    fileprivate var _mergedPathID: Symbolic_Pb_UUID? = nil
    fileprivate var _mergedEndingNodeID: Symbolic_Pb_UUID? = nil
  }

  struct Split: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodeID: Symbolic_Pb_UUID {
      get {return _nodeID ?? Symbolic_Pb_UUID()}
      set {_nodeID = newValue}
    }
    /// Returns true if `nodeID` has been explicitly set.
    var hasNodeID: Bool {return self._nodeID != nil}
    /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
    mutating func clearNodeID() {self._nodeID = nil}

    var newPathID: Symbolic_Pb_UUID {
      get {return _newPathID ?? Symbolic_Pb_UUID()}
      set {_newPathID = newValue}
    }
    /// Returns true if `newPathID` has been explicitly set.
    var hasNewPathID: Bool {return self._newPathID != nil}
    /// Clears the value of `newPathID`. Subsequent reads from it will return its default value.
    mutating func clearNewPathID() {self._newPathID = nil}

    var newNodeID: Symbolic_Pb_UUID {
      get {return _newNodeID ?? Symbolic_Pb_UUID()}
      set {_newNodeID = newValue}
    }
    /// Returns true if `newNodeID` has been explicitly set.
    var hasNewNodeID: Bool {return self._newNodeID != nil}
    /// Clears the value of `newNodeID`. Subsequent reads from it will return its default value.
    mutating func clearNewNodeID() {self._newNodeID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
    fileprivate var _newPathID: Symbolic_Pb_UUID? = nil
    fileprivate var _newNodeID: Symbolic_Pb_UUID? = nil
  }

  struct Delete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Move: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var offset: Symbolic_Pb_Vector2 {
      get {return _offset ?? Symbolic_Pb_Vector2()}
      set {_offset = newValue}
    }
    /// Returns true if `offset` has been explicitly set.
    var hasOffset: Bool {return self._offset != nil}
    /// Clears the value of `offset`. Subsequent reads from it will return its default value.
    mutating func clearOffset() {self._offset = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _offset: Symbolic_Pb_Vector2? = nil
  }

  struct SetName: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
  }

  struct SetNodeType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodeIds: [Symbolic_Pb_UUID] = []

    var nodeType: Symbolic_Pb_PathNodeType {
      get {return _nodeType ?? .corner}
      set {_nodeType = newValue}
    }
    /// Returns true if `nodeType` has been explicitly set.
    var hasNodeType: Bool {return self._nodeType != nil}
    /// Clears the value of `nodeType`. Subsequent reads from it will return its default value.
    mutating func clearNodeType() {self._nodeType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _nodeType: Symbolic_Pb_PathNodeType? = nil
  }

  struct SetSegmentType: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fromNodeIds: [Symbolic_Pb_UUID] = []

    var segmentType: Symbolic_Pb_PathSegmentType {
      get {return _segmentType ?? .cubic}
      set {_segmentType = newValue}
    }
    /// Returns true if `segmentType` has been explicitly set.
    var hasSegmentType: Bool {return self._segmentType != nil}
    /// Clears the value of `segmentType`. Subsequent reads from it will return its default value.
    mutating func clearSegmentType() {self._segmentType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _segmentType: Symbolic_Pb_PathSegmentType? = nil
  }

  struct Kind: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Symbolic_Pb_PathEvent.Kind.OneOf_Kind? = nil

    var create: Symbolic_Pb_PathEvent.Create {
      get {
        if case .create(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.Create()
      }
      set {kind = .create(newValue)}
    }

    var createNode: Symbolic_Pb_PathEvent.CreateNode {
      get {
        if case .createNode(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.CreateNode()
      }
      set {kind = .createNode(newValue)}
    }

    var updateNode: Symbolic_Pb_PathEvent.UpdateNode {
      get {
        if case .updateNode(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.UpdateNode()
      }
      set {kind = .updateNode(newValue)}
    }

    var deleteNode: Symbolic_Pb_PathEvent.DeleteNode {
      get {
        if case .deleteNode(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.DeleteNode()
      }
      set {kind = .deleteNode(newValue)}
    }

    var merge: Symbolic_Pb_PathEvent.Merge {
      get {
        if case .merge(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.Merge()
      }
      set {kind = .merge(newValue)}
    }

    var split: Symbolic_Pb_PathEvent.Split {
      get {
        if case .split(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.Split()
      }
      set {kind = .split(newValue)}
    }

    var delete: Symbolic_Pb_PathEvent.Delete {
      get {
        if case .delete(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.Delete()
      }
      set {kind = .delete(newValue)}
    }

    var move: Symbolic_Pb_PathEvent.Move {
      get {
        if case .move(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.Move()
      }
      set {kind = .move(newValue)}
    }

    var setName: Symbolic_Pb_PathEvent.SetName {
      get {
        if case .setName(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.SetName()
      }
      set {kind = .setName(newValue)}
    }

    var setNodeType: Symbolic_Pb_PathEvent.SetNodeType {
      get {
        if case .setNodeType(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.SetNodeType()
      }
      set {kind = .setNodeType(newValue)}
    }

    var setSegmentType: Symbolic_Pb_PathEvent.SetSegmentType {
      get {
        if case .setSegmentType(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent.SetSegmentType()
      }
      set {kind = .setSegmentType(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
      case create(Symbolic_Pb_PathEvent.Create)
      case createNode(Symbolic_Pb_PathEvent.CreateNode)
      case updateNode(Symbolic_Pb_PathEvent.UpdateNode)
      case deleteNode(Symbolic_Pb_PathEvent.DeleteNode)
      case merge(Symbolic_Pb_PathEvent.Merge)
      case split(Symbolic_Pb_PathEvent.Split)
      case delete(Symbolic_Pb_PathEvent.Delete)
      case move(Symbolic_Pb_PathEvent.Move)
      case setName(Symbolic_Pb_PathEvent.SetName)
      case setNodeType(Symbolic_Pb_PathEvent.SetNodeType)
      case setSegmentType(Symbolic_Pb_PathEvent.SetSegmentType)

    }

    init() {}
  }

  init() {}
}

struct Symbolic_Pb_SymbolEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var symbolIds: [Symbolic_Pb_UUID] = []

  var kinds: [Symbolic_Pb_SymbolEvent.Kind] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Create: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var origin: Symbolic_Pb_Point2 {
      get {return _origin ?? Symbolic_Pb_Point2()}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var size: Symbolic_Pb_Size2 {
      get {return _size ?? Symbolic_Pb_Size2()}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating func clearSize() {self._size = nil}

    var grids: [Symbolic_Pb_Grid] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _origin: Symbolic_Pb_Point2? = nil
    fileprivate var _size: Symbolic_Pb_Size2? = nil
  }

  struct SetBounds: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var origin: Symbolic_Pb_Point2 {
      get {return _origin ?? Symbolic_Pb_Point2()}
      set {_origin = newValue}
    }
    /// Returns true if `origin` has been explicitly set.
    var hasOrigin: Bool {return self._origin != nil}
    /// Clears the value of `origin`. Subsequent reads from it will return its default value.
    mutating func clearOrigin() {self._origin = nil}

    var size: Symbolic_Pb_Size2 {
      get {return _size ?? Symbolic_Pb_Size2()}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    mutating func clearSize() {self._size = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _origin: Symbolic_Pb_Point2? = nil
    fileprivate var _size: Symbolic_Pb_Size2? = nil
  }

  struct SetGrid: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var index: UInt32 = 0

    var grid: Symbolic_Pb_Grid {
      get {return _grid ?? Symbolic_Pb_Grid()}
      set {_grid = newValue}
    }
    /// Returns true if `grid` has been explicitly set.
    var hasGrid: Bool {return self._grid != nil}
    /// Clears the value of `grid`. Subsequent reads from it will return its default value.
    mutating func clearGrid() {self._grid = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _grid: Symbolic_Pb_Grid? = nil
  }

  struct SetMembers: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var members: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Delete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Move: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var offset: Symbolic_Pb_Vector2 {
      get {return _offset ?? Symbolic_Pb_Vector2()}
      set {_offset = newValue}
    }
    /// Returns true if `offset` has been explicitly set.
    var hasOffset: Bool {return self._offset != nil}
    /// Clears the value of `offset`. Subsequent reads from it will return its default value.
    mutating func clearOffset() {self._offset = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _offset: Symbolic_Pb_Vector2? = nil
  }

  struct Kind: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Symbolic_Pb_SymbolEvent.Kind.OneOf_Kind? = nil

    var create: Symbolic_Pb_SymbolEvent.Create {
      get {
        if case .create(let v)? = kind {return v}
        return Symbolic_Pb_SymbolEvent.Create()
      }
      set {kind = .create(newValue)}
    }

    var setBounds: Symbolic_Pb_SymbolEvent.SetBounds {
      get {
        if case .setBounds(let v)? = kind {return v}
        return Symbolic_Pb_SymbolEvent.SetBounds()
      }
      set {kind = .setBounds(newValue)}
    }

    var setGrid: Symbolic_Pb_SymbolEvent.SetGrid {
      get {
        if case .setGrid(let v)? = kind {return v}
        return Symbolic_Pb_SymbolEvent.SetGrid()
      }
      set {kind = .setGrid(newValue)}
    }

    var setMembers: Symbolic_Pb_SymbolEvent.SetMembers {
      get {
        if case .setMembers(let v)? = kind {return v}
        return Symbolic_Pb_SymbolEvent.SetMembers()
      }
      set {kind = .setMembers(newValue)}
    }

    var delete: Symbolic_Pb_SymbolEvent.Delete {
      get {
        if case .delete(let v)? = kind {return v}
        return Symbolic_Pb_SymbolEvent.Delete()
      }
      set {kind = .delete(newValue)}
    }

    var move: Symbolic_Pb_SymbolEvent.Move {
      get {
        if case .move(let v)? = kind {return v}
        return Symbolic_Pb_SymbolEvent.Move()
      }
      set {kind = .move(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
      case create(Symbolic_Pb_SymbolEvent.Create)
      case setBounds(Symbolic_Pb_SymbolEvent.SetBounds)
      case setGrid(Symbolic_Pb_SymbolEvent.SetGrid)
      case setMembers(Symbolic_Pb_SymbolEvent.SetMembers)
      case delete(Symbolic_Pb_SymbolEvent.Delete)
      case move(Symbolic_Pb_SymbolEvent.Move)

    }

    init() {}
  }

  init() {}
}

struct Symbolic_Pb_ItemEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_ItemEvent.OneOf_Kind? = nil

  var setGroup: Symbolic_Pb_ItemEvent.SetGroup {
    get {
      if case .setGroup(let v)? = kind {return v}
      return Symbolic_Pb_ItemEvent.SetGroup()
    }
    set {kind = .setGroup(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case setGroup(Symbolic_Pb_ItemEvent.SetGroup)

  }

  struct SetGroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupID: Symbolic_Pb_UUID {
      get {return _groupID ?? Symbolic_Pb_UUID()}
      set {_groupID = newValue}
    }
    /// Returns true if `groupID` has been explicitly set.
    var hasGroupID: Bool {return self._groupID != nil}
    /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
    mutating func clearGroupID() {self._groupID = nil}

    var members: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _groupID: Symbolic_Pb_UUID? = nil
  }

  init() {}
}

struct Symbolic_Pb_DocumentEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Symbolic_Pb_UUID {
    get {return _id ?? Symbolic_Pb_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var kind: Symbolic_Pb_DocumentEvent.OneOf_Kind? = nil

  var single: Symbolic_Pb_DocumentEvent.Single {
    get {
      if case .single(let v)? = kind {return v}
      return Symbolic_Pb_DocumentEvent.Single()
    }
    set {kind = .single(newValue)}
  }

  var compound: Symbolic_Pb_DocumentEvent.Compound {
    get {
      if case .compound(let v)? = kind {return v}
      return Symbolic_Pb_DocumentEvent.Compound()
    }
    set {kind = .compound(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case single(Symbolic_Pb_DocumentEvent.Single)
    case compound(Symbolic_Pb_DocumentEvent.Compound)

  }

  struct Single: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Symbolic_Pb_DocumentEvent.Single.OneOf_Kind? = nil

    var pathEvent: Symbolic_Pb_PathEvent {
      get {
        if case .pathEvent(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent()
      }
      set {kind = .pathEvent(newValue)}
    }

    var symbolEvent: Symbolic_Pb_SymbolEvent {
      get {
        if case .symbolEvent(let v)? = kind {return v}
        return Symbolic_Pb_SymbolEvent()
      }
      set {kind = .symbolEvent(newValue)}
    }

    var itemEvent: Symbolic_Pb_ItemEvent {
      get {
        if case .itemEvent(let v)? = kind {return v}
        return Symbolic_Pb_ItemEvent()
      }
      set {kind = .itemEvent(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
      case pathEvent(Symbolic_Pb_PathEvent)
      case symbolEvent(Symbolic_Pb_SymbolEvent)
      case itemEvent(Symbolic_Pb_ItemEvent)

    }

    init() {}
  }

  struct Compound: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var events: [Symbolic_Pb_DocumentEvent.Single] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _id: Symbolic_Pb_UUID? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "symbolic.pb"

extension Symbolic_Pb_PathEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_ids"),
    2: .same(proto: "kinds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pathIds) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.kinds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathIds, fieldNumber: 1)
    }
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kinds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent, rhs: Symbolic_Pb_PathEvent) -> Bool {
    if lhs.pathIds != rhs.pathIds {return false}
    if lhs.kinds != rhs.kinds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Create"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Create, rhs: Symbolic_Pb_PathEvent.Create) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.CreateNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".CreateNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prev_node_id"),
    2: .standard(proto: "node_id"),
    3: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._prevNodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prevNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.CreateNode, rhs: Symbolic_Pb_PathEvent.CreateNode) -> Bool {
    if lhs._prevNodeID != rhs._prevNodeID {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.UpdateNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".UpdateNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.UpdateNode, rhs: Symbolic_Pb_PathEvent.UpdateNode) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.DeleteNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".DeleteNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.DeleteNode, rhs: Symbolic_Pb_PathEvent.DeleteNode) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Merge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Merge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ending_node_id"),
    2: .standard(proto: "merged_path_id"),
    3: .standard(proto: "merged_ending_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endingNodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mergedPathID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mergedEndingNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mergedPathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mergedEndingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Merge, rhs: Symbolic_Pb_PathEvent.Merge) -> Bool {
    if lhs._endingNodeID != rhs._endingNodeID {return false}
    if lhs._mergedPathID != rhs._mergedPathID {return false}
    if lhs._mergedEndingNodeID != rhs._mergedEndingNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Split: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Split"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "new_path_id"),
    3: .standard(proto: "new_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newPathID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newPathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Split, rhs: Symbolic_Pb_PathEvent.Split) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._newPathID != rhs._newPathID {return false}
    if lhs._newNodeID != rhs._newNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Delete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Delete, rhs: Symbolic_Pb_PathEvent.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Move"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Move, rhs: Symbolic_Pb_PathEvent.Move) -> Bool {
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.SetName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".SetName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.SetName, rhs: Symbolic_Pb_PathEvent.SetName) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.SetNodeType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".SetNodeType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
    2: .standard(proto: "node_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._nodeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    try { if let v = self._nodeType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.SetNodeType, rhs: Symbolic_Pb_PathEvent.SetNodeType) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs._nodeType != rhs._nodeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.SetSegmentType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".SetSegmentType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node_ids"),
    2: .standard(proto: "segment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fromNodeIds) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._segmentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fromNodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fromNodeIds, fieldNumber: 1)
    }
    try { if let v = self._segmentType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.SetSegmentType, rhs: Symbolic_Pb_PathEvent.SetSegmentType) -> Bool {
    if lhs.fromNodeIds != rhs.fromNodeIds {return false}
    if lhs._segmentType != rhs._segmentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Kind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Kind"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "create"),
    102: .same(proto: "createNode"),
    103: .same(proto: "updateNode"),
    104: .same(proto: "deleteNode"),
    105: .same(proto: "merge"),
    106: .same(proto: "split"),
    201: .same(proto: "delete"),
    202: .same(proto: "move"),
    301: .standard(proto: "set_name"),
    302: .standard(proto: "set_node_type"),
    303: .standard(proto: "set_segment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathEvent.Create?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .create(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathEvent.CreateNode?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .createNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .createNode(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathEvent.UpdateNode?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .updateNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .updateNode(v)
        }
      }()
      case 104: try {
        var v: Symbolic_Pb_PathEvent.DeleteNode?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .deleteNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .deleteNode(v)
        }
      }()
      case 105: try {
        var v: Symbolic_Pb_PathEvent.Merge?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .merge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .merge(v)
        }
      }()
      case 106: try {
        var v: Symbolic_Pb_PathEvent.Split?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .split(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .split(v)
        }
      }()
      case 201: try {
        var v: Symbolic_Pb_PathEvent.Delete?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .delete(v)
        }
      }()
      case 202: try {
        var v: Symbolic_Pb_PathEvent.Move?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .move(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .move(v)
        }
      }()
      case 301: try {
        var v: Symbolic_Pb_PathEvent.SetName?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setName(v)
        }
      }()
      case 302: try {
        var v: Symbolic_Pb_PathEvent.SetNodeType?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setNodeType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setNodeType(v)
        }
      }()
      case 303: try {
        var v: Symbolic_Pb_PathEvent.SetSegmentType?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setSegmentType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setSegmentType(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .create?: try {
      guard case .create(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .createNode?: try {
      guard case .createNode(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .updateNode?: try {
      guard case .updateNode(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .deleteNode?: try {
      guard case .deleteNode(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .merge?: try {
      guard case .merge(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .split?: try {
      guard case .split(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
    }()
    case .move?: try {
      guard case .move(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 202)
    }()
    case .setName?: try {
      guard case .setName(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 301)
    }()
    case .setNodeType?: try {
      guard case .setNodeType(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 302)
    }()
    case .setSegmentType?: try {
      guard case .setSegmentType(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 303)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Kind, rhs: Symbolic_Pb_PathEvent.Kind) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SymbolEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symbol_ids"),
    2: .same(proto: "kinds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.symbolIds) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.kinds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbolIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.symbolIds, fieldNumber: 1)
    }
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kinds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolEvent, rhs: Symbolic_Pb_SymbolEvent) -> Bool {
    if lhs.symbolIds != rhs.symbolIds {return false}
    if lhs.kinds != rhs.kinds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolEvent.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolEvent.protoMessageName + ".Create"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "size"),
    3: .same(proto: "grids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.grids) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.grids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.grids, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolEvent.Create, rhs: Symbolic_Pb_SymbolEvent.Create) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.grids != rhs.grids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolEvent.SetBounds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolEvent.protoMessageName + ".SetBounds"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "origin"),
    2: .same(proto: "size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._origin) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._origin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolEvent.SetBounds, rhs: Symbolic_Pb_SymbolEvent.SetBounds) -> Bool {
    if lhs._origin != rhs._origin {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolEvent.SetGrid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolEvent.protoMessageName + ".SetGrid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "grid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._grid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    try { if let v = self._grid {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolEvent.SetGrid, rhs: Symbolic_Pb_SymbolEvent.SetGrid) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs._grid != rhs._grid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolEvent.SetMembers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolEvent.protoMessageName + ".SetMembers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolEvent.SetMembers, rhs: Symbolic_Pb_SymbolEvent.SetMembers) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolEvent.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolEvent.protoMessageName + ".Delete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolEvent.Delete, rhs: Symbolic_Pb_SymbolEvent.Delete) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolEvent.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolEvent.protoMessageName + ".Move"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolEvent.Move, rhs: Symbolic_Pb_SymbolEvent.Move) -> Bool {
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_SymbolEvent.Kind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_SymbolEvent.protoMessageName + ".Kind"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "create"),
    102: .standard(proto: "set_bounds"),
    103: .standard(proto: "set_grid"),
    104: .standard(proto: "set_members"),
    201: .same(proto: "delete"),
    202: .same(proto: "move"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_SymbolEvent.Create?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .create(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_SymbolEvent.SetBounds?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setBounds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setBounds(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_SymbolEvent.SetGrid?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setGrid(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setGrid(v)
        }
      }()
      case 104: try {
        var v: Symbolic_Pb_SymbolEvent.SetMembers?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setMembers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setMembers(v)
        }
      }()
      case 201: try {
        var v: Symbolic_Pb_SymbolEvent.Delete?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .delete(v)
        }
      }()
      case 202: try {
        var v: Symbolic_Pb_SymbolEvent.Move?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .move(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .move(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .create?: try {
      guard case .create(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .setBounds?: try {
      guard case .setBounds(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .setGrid?: try {
      guard case .setGrid(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .setMembers?: try {
      guard case .setMembers(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
    }()
    case .move?: try {
      guard case .move(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 202)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_SymbolEvent.Kind, rhs: Symbolic_Pb_SymbolEvent.Kind) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ItemEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .standard(proto: "set_group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_ItemEvent.SetGroup?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setGroup(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .setGroup(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemEvent, rhs: Symbolic_Pb_ItemEvent) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemEvent.SetGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemEvent.protoMessageName + ".SetGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemEvent.SetGroup, rhs: Symbolic_Pb_ItemEvent.SetGroup) -> Bool {
    if lhs._groupID != rhs._groupID {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_DocumentEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "time"),
    101: .same(proto: "single"),
    102: .same(proto: "compound"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 101: try {
        var v: Symbolic_Pb_DocumentEvent.Single?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .single(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .single(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_DocumentEvent.Compound?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .compound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .compound(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.kind {
    case .single?: try {
      guard case .single(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .compound?: try {
      guard case .compound(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_DocumentEvent, rhs: Symbolic_Pb_DocumentEvent) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._time != rhs._time {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_DocumentEvent.Single: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_DocumentEvent.protoMessageName + ".Single"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .standard(proto: "path_event"),
    102: .standard(proto: "symbol_event"),
    103: .standard(proto: "item_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathEvent?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .pathEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .pathEvent(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_SymbolEvent?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .symbolEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .symbolEvent(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_ItemEvent?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .itemEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .itemEvent(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .pathEvent?: try {
      guard case .pathEvent(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .symbolEvent?: try {
      guard case .symbolEvent(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .itemEvent?: try {
      guard case .itemEvent(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_DocumentEvent.Single, rhs: Symbolic_Pb_DocumentEvent.Single) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_DocumentEvent.Compound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_DocumentEvent.protoMessageName + ".Compound"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_DocumentEvent.Compound, rhs: Symbolic_Pb_DocumentEvent.Compound) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
