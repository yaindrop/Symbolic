// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/symbolic.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Symbolic_Pb_PathNodeControlType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case cubicIn // = 0
  case cubicOut // = 1
  case quadraticOut // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .cubicIn
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cubicIn
    case 1: self = .cubicOut
    case 2: self = .quadraticOut
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cubicIn: return 0
    case .cubicOut: return 1
    case .quadraticOut: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Symbolic_Pb_PathNodeControlType] = [
    .cubicIn,
    .cubicOut,
    .quadraticOut,
  ]

}

enum Symbolic_Pb_PathNodeType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case corner // = 0
  case locked // = 1
  case mirrored // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .corner
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .corner
    case 1: self = .locked
    case 2: self = .mirrored
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .corner: return 0
    case .locked: return 1
    case .mirrored: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Symbolic_Pb_PathNodeType] = [
    .corner,
    .locked,
    .mirrored,
  ]

}

enum Symbolic_Pb_PathSegmentType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case cubic // = 0
  case quadratic // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .cubic
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cubic
    case 1: self = .quadratic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cubic: return 0
    case .quadratic: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Symbolic_Pb_PathSegmentType] = [
    .cubic,
    .quadratic,
  ]

}

/// A UUID, encoded in accordance with section 4.1.2 of RFC 4122.
struct Symbolic_Pb_UUID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The higher 64 bits of the UUID, big-endian:
  /// time_low (32) | time_mid (16) | time_hi_and_version (16)
  var hi: UInt64 = 0

  /// The lower 64 bits of the UUID, big-endian:
  /// clock_seq_hi_and_reserved (8) | clock_seq_low (8) | node (48)
  var lo: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_Vector2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_Point2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_Size2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Double = 0

  var height: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_PathNode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: Symbolic_Pb_Point2 {
    get {return _position ?? Symbolic_Pb_Point2()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var cubicIn: Symbolic_Pb_Vector2 {
    get {return _cubicIn ?? Symbolic_Pb_Vector2()}
    set {_cubicIn = newValue}
  }
  /// Returns true if `cubicIn` has been explicitly set.
  var hasCubicIn: Bool {return self._cubicIn != nil}
  /// Clears the value of `cubicIn`. Subsequent reads from it will return its default value.
  mutating func clearCubicIn() {self._cubicIn = nil}

  var cubicOut: Symbolic_Pb_Vector2 {
    get {return _cubicOut ?? Symbolic_Pb_Vector2()}
    set {_cubicOut = newValue}
  }
  /// Returns true if `cubicOut` has been explicitly set.
  var hasCubicOut: Bool {return self._cubicOut != nil}
  /// Clears the value of `cubicOut`. Subsequent reads from it will return its default value.
  mutating func clearCubicOut() {self._cubicOut = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Symbolic_Pb_Point2? = nil
  fileprivate var _cubicIn: Symbolic_Pb_Vector2? = nil
  fileprivate var _cubicOut: Symbolic_Pb_Vector2? = nil
}

struct Symbolic_Pb_PathSegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: Symbolic_Pb_Point2 {
    get {return _from ?? Symbolic_Pb_Point2()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var to: Symbolic_Pb_Point2 {
    get {return _to ?? Symbolic_Pb_Point2()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  mutating func clearTo() {self._to = nil}

  var fromCubicOut: Symbolic_Pb_Vector2 {
    get {return _fromCubicOut ?? Symbolic_Pb_Vector2()}
    set {_fromCubicOut = newValue}
  }
  /// Returns true if `fromCubicOut` has been explicitly set.
  var hasFromCubicOut: Bool {return self._fromCubicOut != nil}
  /// Clears the value of `fromCubicOut`. Subsequent reads from it will return its default value.
  mutating func clearFromCubicOut() {self._fromCubicOut = nil}

  var toCubicIn: Symbolic_Pb_Vector2 {
    get {return _toCubicIn ?? Symbolic_Pb_Vector2()}
    set {_toCubicIn = newValue}
  }
  /// Returns true if `toCubicIn` has been explicitly set.
  var hasToCubicIn: Bool {return self._toCubicIn != nil}
  /// Clears the value of `toCubicIn`. Subsequent reads from it will return its default value.
  mutating func clearToCubicIn() {self._toCubicIn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _from: Symbolic_Pb_Point2? = nil
  fileprivate var _to: Symbolic_Pb_Point2? = nil
  fileprivate var _fromCubicOut: Symbolic_Pb_Vector2? = nil
  fileprivate var _toCubicIn: Symbolic_Pb_Vector2? = nil
}

struct Symbolic_Pb_Path: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeIds: [Symbolic_Pb_UUID] = []

  var nodes: [Symbolic_Pb_PathNode] = []

  var isClosed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "symbolic.pb"

extension Symbolic_Pb_PathNodeControlType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "cubicIn"),
    1: .same(proto: "cubicOut"),
    2: .same(proto: "quadraticOut"),
  ]
}

extension Symbolic_Pb_PathNodeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "corner"),
    1: .same(proto: "locked"),
    2: .same(proto: "mirrored"),
  ]
}

extension Symbolic_Pb_PathSegmentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "cubic"),
    1: .same(proto: "quadratic"),
  ]
}

extension Symbolic_Pb_UUID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hi"),
    2: .same(proto: "lo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.hi) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.lo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hi != 0 {
      try visitor.visitSingularFixed64Field(value: self.hi, fieldNumber: 1)
    }
    if self.lo != 0 {
      try visitor.visitSingularFixed64Field(value: self.lo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_UUID, rhs: Symbolic_Pb_UUID) -> Bool {
    if lhs.hi != rhs.hi {return false}
    if lhs.lo != rhs.lo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Vector2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vector2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Vector2, rhs: Symbolic_Pb_Vector2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Point2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Point2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Point2, rhs: Symbolic_Pb_Point2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Size2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Size2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 1)
    }
    if self.height.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Size2, rhs: Symbolic_Pb_Size2) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "cubic_in"),
    3: .standard(proto: "cubic_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cubicIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cubicOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cubicIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cubicOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathNode, rhs: Symbolic_Pb_PathNode) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._cubicIn != rhs._cubicIn {return false}
    if lhs._cubicOut != rhs._cubicOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathSegment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .standard(proto: "from_cubic_out"),
    4: .standard(proto: "to_cubic_in"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fromCubicOut) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._toCubicIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fromCubicOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._toCubicIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathSegment, rhs: Symbolic_Pb_PathSegment) -> Bool {
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs._fromCubicOut != rhs._fromCubicOut {return false}
    if lhs._toCubicIn != rhs._toCubicIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Path"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
    2: .same(proto: "nodes"),
    3: .standard(proto: "is_closed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isClosed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 2)
    }
    if self.isClosed != false {
      try visitor.visitSingularBoolField(value: self.isClosed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Path, rhs: Symbolic_Pb_Path) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs.isClosed != rhs.isClosed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
