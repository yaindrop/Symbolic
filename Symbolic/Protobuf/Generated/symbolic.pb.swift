// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/symbolic.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Symbolic_Pb_PlaneInnerAlign: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case topLeading // = 0
  case topCenter // = 1
  case topTrailing // = 2
  case centerLeading // = 3
  case center // = 4
  case centerTrailing // = 5
  case bottomLeading // = 6
  case bottomCenter // = 7
  case bottomTrailing // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .topLeading
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .topLeading
    case 1: self = .topCenter
    case 2: self = .topTrailing
    case 3: self = .centerLeading
    case 4: self = .center
    case 5: self = .centerTrailing
    case 6: self = .bottomLeading
    case 7: self = .bottomCenter
    case 8: self = .bottomTrailing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .topLeading: return 0
    case .topCenter: return 1
    case .topTrailing: return 2
    case .centerLeading: return 3
    case .center: return 4
    case .centerTrailing: return 5
    case .bottomLeading: return 6
    case .bottomCenter: return 7
    case .bottomTrailing: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Symbolic_Pb_PlaneInnerAlign] = [
    .topLeading,
    .topCenter,
    .topTrailing,
    .centerLeading,
    .center,
    .centerTrailing,
    .bottomLeading,
    .bottomCenter,
    .bottomTrailing,
  ]

}

enum Symbolic_Pb_PathNodeControlType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case cubicIn // = 0
  case cubicOut // = 1
  case quadraticOut // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .cubicIn
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cubicIn
    case 1: self = .cubicOut
    case 2: self = .quadraticOut
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cubicIn: return 0
    case .cubicOut: return 1
    case .quadraticOut: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Symbolic_Pb_PathNodeControlType] = [
    .cubicIn,
    .cubicOut,
    .quadraticOut,
  ]

}

enum Symbolic_Pb_PathNodeType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case corner // = 0
  case locked // = 1
  case mirrored // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .corner
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .corner
    case 1: self = .locked
    case 2: self = .mirrored
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .corner: return 0
    case .locked: return 1
    case .mirrored: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Symbolic_Pb_PathNodeType] = [
    .corner,
    .locked,
    .mirrored,
  ]

}

enum Symbolic_Pb_PathSegmentType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case cubic // = 0
  case quadratic // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .cubic
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .cubic
    case 1: self = .quadratic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .cubic: return 0
    case .quadratic: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Symbolic_Pb_PathSegmentType] = [
    .cubic,
    .quadratic,
  ]

}

/// A UUID, encoded in accordance with section 4.1.2 of RFC 4122.
struct Symbolic_Pb_UUID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The higher 64 bits of the UUID, big-endian:
  /// time_low (32) | time_mid (16) | time_hi_and_version (16)
  var hi: UInt64 = 0

  /// The lower 64 bits of the UUID, big-endian:
  /// clock_seq_hi_and_reserved (8) | clock_seq_low (8) | node (48)
  var lo: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_Vector2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_Point2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var x: Double = 0

  var y: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_Size2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Double = 0

  var height: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_Angle: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var radians: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_Color: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var red: Double = 0

  var green: Double = 0

  var blue: Double = 0

  var alpha: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_PathNode: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: Symbolic_Pb_Point2 {
    get {return _position ?? Symbolic_Pb_Point2()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var cubicIn: Symbolic_Pb_Vector2 {
    get {return _cubicIn ?? Symbolic_Pb_Vector2()}
    set {_cubicIn = newValue}
  }
  /// Returns true if `cubicIn` has been explicitly set.
  var hasCubicIn: Bool {return self._cubicIn != nil}
  /// Clears the value of `cubicIn`. Subsequent reads from it will return its default value.
  mutating func clearCubicIn() {self._cubicIn = nil}

  var cubicOut: Symbolic_Pb_Vector2 {
    get {return _cubicOut ?? Symbolic_Pb_Vector2()}
    set {_cubicOut = newValue}
  }
  /// Returns true if `cubicOut` has been explicitly set.
  var hasCubicOut: Bool {return self._cubicOut != nil}
  /// Clears the value of `cubicOut`. Subsequent reads from it will return its default value.
  mutating func clearCubicOut() {self._cubicOut = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: Symbolic_Pb_Point2? = nil
  fileprivate var _cubicIn: Symbolic_Pb_Vector2? = nil
  fileprivate var _cubicOut: Symbolic_Pb_Vector2? = nil
}

struct Symbolic_Pb_PathSegment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: Symbolic_Pb_Point2 {
    get {return _from ?? Symbolic_Pb_Point2()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {self._from = nil}

  var to: Symbolic_Pb_Point2 {
    get {return _to ?? Symbolic_Pb_Point2()}
    set {_to = newValue}
  }
  /// Returns true if `to` has been explicitly set.
  var hasTo: Bool {return self._to != nil}
  /// Clears the value of `to`. Subsequent reads from it will return its default value.
  mutating func clearTo() {self._to = nil}

  var fromCubicOut: Symbolic_Pb_Vector2 {
    get {return _fromCubicOut ?? Symbolic_Pb_Vector2()}
    set {_fromCubicOut = newValue}
  }
  /// Returns true if `fromCubicOut` has been explicitly set.
  var hasFromCubicOut: Bool {return self._fromCubicOut != nil}
  /// Clears the value of `fromCubicOut`. Subsequent reads from it will return its default value.
  mutating func clearFromCubicOut() {self._fromCubicOut = nil}

  var toCubicIn: Symbolic_Pb_Vector2 {
    get {return _toCubicIn ?? Symbolic_Pb_Vector2()}
    set {_toCubicIn = newValue}
  }
  /// Returns true if `toCubicIn` has been explicitly set.
  var hasToCubicIn: Bool {return self._toCubicIn != nil}
  /// Clears the value of `toCubicIn`. Subsequent reads from it will return its default value.
  mutating func clearToCubicIn() {self._toCubicIn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _from: Symbolic_Pb_Point2? = nil
  fileprivate var _to: Symbolic_Pb_Point2? = nil
  fileprivate var _fromCubicOut: Symbolic_Pb_Vector2? = nil
  fileprivate var _toCubicIn: Symbolic_Pb_Vector2? = nil
}

struct Symbolic_Pb_Path: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nodeIds: [Symbolic_Pb_UUID] = []

  var nodes: [Symbolic_Pb_PathNode] = []

  var isClosed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Symbolic_Pb_Grid: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tintColor: Symbolic_Pb_Color {
    get {return _tintColor ?? Symbolic_Pb_Color()}
    set {_tintColor = newValue}
  }
  /// Returns true if `tintColor` has been explicitly set.
  var hasTintColor: Bool {return self._tintColor != nil}
  /// Clears the value of `tintColor`. Subsequent reads from it will return its default value.
  mutating func clearTintColor() {self._tintColor = nil}

  var kind: Symbolic_Pb_Grid.OneOf_Kind? = nil

  var cartesian: Symbolic_Pb_Grid.Cartesian {
    get {
      if case .cartesian(let v)? = kind {return v}
      return Symbolic_Pb_Grid.Cartesian()
    }
    set {kind = .cartesian(newValue)}
  }

  var isometric: Symbolic_Pb_Grid.Isometric {
    get {
      if case .isometric(let v)? = kind {return v}
      return Symbolic_Pb_Grid.Isometric()
    }
    set {kind = .isometric(newValue)}
  }

  var radial: Symbolic_Pb_Grid.Radial {
    get {
      if case .radial(let v)? = kind {return v}
      return Symbolic_Pb_Grid.Radial()
    }
    set {kind = .radial(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case cartesian(Symbolic_Pb_Grid.Cartesian)
    case isometric(Symbolic_Pb_Grid.Isometric)
    case radial(Symbolic_Pb_Grid.Radial)

  }

  struct Cartesian: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var interval: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Isometric: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var interval: Double = 0

    var angle0: Symbolic_Pb_Angle {
      get {return _angle0 ?? Symbolic_Pb_Angle()}
      set {_angle0 = newValue}
    }
    /// Returns true if `angle0` has been explicitly set.
    var hasAngle0: Bool {return self._angle0 != nil}
    /// Clears the value of `angle0`. Subsequent reads from it will return its default value.
    mutating func clearAngle0() {self._angle0 = nil}

    var angle1: Symbolic_Pb_Angle {
      get {return _angle1 ?? Symbolic_Pb_Angle()}
      set {_angle1 = newValue}
    }
    /// Returns true if `angle1` has been explicitly set.
    var hasAngle1: Bool {return self._angle1 != nil}
    /// Clears the value of `angle1`. Subsequent reads from it will return its default value.
    mutating func clearAngle1() {self._angle1 = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _angle0: Symbolic_Pb_Angle? = nil
    fileprivate var _angle1: Symbolic_Pb_Angle? = nil
  }

  struct Radial: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var interval: Double = 0

    var angularDivisions: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _tintColor: Symbolic_Pb_Color? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "symbolic.pb"

extension Symbolic_Pb_PlaneInnerAlign: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "topLeading"),
    1: .same(proto: "topCenter"),
    2: .same(proto: "topTrailing"),
    3: .same(proto: "centerLeading"),
    4: .same(proto: "center"),
    5: .same(proto: "centerTrailing"),
    6: .same(proto: "bottomLeading"),
    7: .same(proto: "bottomCenter"),
    8: .same(proto: "bottomTrailing"),
  ]
}

extension Symbolic_Pb_PathNodeControlType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "cubicIn"),
    1: .same(proto: "cubicOut"),
    2: .same(proto: "quadraticOut"),
  ]
}

extension Symbolic_Pb_PathNodeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "corner"),
    1: .same(proto: "locked"),
    2: .same(proto: "mirrored"),
  ]
}

extension Symbolic_Pb_PathSegmentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "cubic"),
    1: .same(proto: "quadratic"),
  ]
}

extension Symbolic_Pb_UUID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UUID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hi"),
    2: .same(proto: "lo"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.hi) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.lo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hi != 0 {
      try visitor.visitSingularFixed64Field(value: self.hi, fieldNumber: 1)
    }
    if self.lo != 0 {
      try visitor.visitSingularFixed64Field(value: self.lo, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_UUID, rhs: Symbolic_Pb_UUID) -> Bool {
    if lhs.hi != rhs.hi {return false}
    if lhs.lo != rhs.lo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Vector2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vector2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Vector2, rhs: Symbolic_Pb_Vector2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Point2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Point2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Point2, rhs: Symbolic_Pb_Point2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Size2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Size2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.width) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.width, fieldNumber: 1)
    }
    if self.height.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Size2, rhs: Symbolic_Pb_Size2) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Angle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Angle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "radians"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.radians) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.radians.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.radians, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Angle, rhs: Symbolic_Pb_Angle) -> Bool {
    if lhs.radians != rhs.radians {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Color"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "red"),
    2: .same(proto: "green"),
    3: .same(proto: "blue"),
    4: .same(proto: "alpha"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.red) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.green) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.blue) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.alpha) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.red.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.red, fieldNumber: 1)
    }
    if self.green.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.green, fieldNumber: 2)
    }
    if self.blue.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.blue, fieldNumber: 3)
    }
    if self.alpha.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.alpha, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Color, rhs: Symbolic_Pb_Color) -> Bool {
    if lhs.red != rhs.red {return false}
    if lhs.green != rhs.green {return false}
    if lhs.blue != rhs.blue {return false}
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "cubic_in"),
    3: .standard(proto: "cubic_out"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cubicIn) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cubicOut) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cubicIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cubicOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathNode, rhs: Symbolic_Pb_PathNode) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._cubicIn != rhs._cubicIn {return false}
    if lhs._cubicOut != rhs._cubicOut {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathSegment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .standard(proto: "from_cubic_out"),
    4: .standard(proto: "to_cubic_in"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._from) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._to) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fromCubicOut) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._toCubicIn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._to {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fromCubicOut {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._toCubicIn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathSegment, rhs: Symbolic_Pb_PathSegment) -> Bool {
    if lhs._from != rhs._from {return false}
    if lhs._to != rhs._to {return false}
    if lhs._fromCubicOut != rhs._fromCubicOut {return false}
    if lhs._toCubicIn != rhs._toCubicIn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Path"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
    2: .same(proto: "nodes"),
    3: .standard(proto: "is_closed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isClosed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 2)
    }
    if self.isClosed != false {
      try visitor.visitSingularBoolField(value: self.isClosed, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Path, rhs: Symbolic_Pb_Path) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs.isClosed != rhs.isClosed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Grid: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Grid"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tint_color"),
    101: .same(proto: "cartesian"),
    102: .same(proto: "isometric"),
    103: .same(proto: "radial"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tintColor) }()
      case 101: try {
        var v: Symbolic_Pb_Grid.Cartesian?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .cartesian(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .cartesian(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_Grid.Isometric?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .isometric(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .isometric(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_Grid.Radial?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .radial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .radial(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tintColor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.kind {
    case .cartesian?: try {
      guard case .cartesian(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .isometric?: try {
      guard case .isometric(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .radial?: try {
      guard case .radial(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Grid, rhs: Symbolic_Pb_Grid) -> Bool {
    if lhs._tintColor != rhs._tintColor {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Grid.Cartesian: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_Grid.protoMessageName + ".Cartesian"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.interval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.interval.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.interval, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Grid.Cartesian, rhs: Symbolic_Pb_Grid.Cartesian) -> Bool {
    if lhs.interval != rhs.interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Grid.Isometric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_Grid.protoMessageName + ".Isometric"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
    2: .same(proto: "angle0"),
    3: .same(proto: "angle1"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.interval) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._angle0) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._angle1) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.interval.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.interval, fieldNumber: 1)
    }
    try { if let v = self._angle0 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._angle1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Grid.Isometric, rhs: Symbolic_Pb_Grid.Isometric) -> Bool {
    if lhs.interval != rhs.interval {return false}
    if lhs._angle0 != rhs._angle0 {return false}
    if lhs._angle1 != rhs._angle1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_Grid.Radial: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_Grid.protoMessageName + ".Radial"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
    2: .standard(proto: "angular_divisions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.interval) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.angularDivisions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.interval.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.interval, fieldNumber: 1)
    }
    if self.angularDivisions != 0 {
      try visitor.visitSingularUInt32Field(value: self.angularDivisions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_Grid.Radial, rhs: Symbolic_Pb_Grid.Radial) -> Bool {
    if lhs.interval != rhs.interval {return false}
    if lhs.angularDivisions != rhs.angularDivisions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
