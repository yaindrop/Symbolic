// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/document-action.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Symbolic_Pb_ItemAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_ItemAction.OneOf_Kind? = nil

  var group: Symbolic_Pb_ItemAction.Group {
    get {
      if case .group(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction.Group()
    }
    set {kind = .group(newValue)}
  }

  var ungroup: Symbolic_Pb_ItemAction.Ungroup {
    get {
      if case .ungroup(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction.Ungroup()
    }
    set {kind = .ungroup(newValue)}
  }

  var reorder: Symbolic_Pb_ItemAction.Reorder {
    get {
      if case .reorder(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction.Reorder()
    }
    set {kind = .reorder(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case group(Symbolic_Pb_ItemAction.Group)
    case ungroup(Symbolic_Pb_ItemAction.Ungroup)
    case reorder(Symbolic_Pb_ItemAction.Reorder)

  }

  struct Group: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var group: Symbolic_Pb_ItemGroup {
      get {return _group ?? Symbolic_Pb_ItemGroup()}
      set {_group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    var hasGroup: Bool {return self._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    mutating func clearGroup() {self._group = nil}

    var inGroupID: Symbolic_Pb_UUID {
      get {return _inGroupID ?? Symbolic_Pb_UUID()}
      set {_inGroupID = newValue}
    }
    /// Returns true if `inGroupID` has been explicitly set.
    var hasInGroupID: Bool {return self._inGroupID != nil}
    /// Clears the value of `inGroupID`. Subsequent reads from it will return its default value.
    mutating func clearInGroupID() {self._inGroupID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _group: Symbolic_Pb_ItemGroup? = nil
    fileprivate var _inGroupID: Symbolic_Pb_UUID? = nil
  }

  struct Ungroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var groupIds: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Reorder: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var members: [Symbolic_Pb_UUID] = []

    var inGroupID: Symbolic_Pb_UUID {
      get {return _inGroupID ?? Symbolic_Pb_UUID()}
      set {_inGroupID = newValue}
    }
    /// Returns true if `inGroupID` has been explicitly set.
    var hasInGroupID: Bool {return self._inGroupID != nil}
    /// Clears the value of `inGroupID`. Subsequent reads from it will return its default value.
    mutating func clearInGroupID() {self._inGroupID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _inGroupID: Symbolic_Pb_UUID? = nil
  }

  init() {}
}

struct Symbolic_Pb_PathAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_PathAction.OneOf_Kind? = nil

  var create: Symbolic_Pb_PathAction.Create {
    get {
      if case .create(let v)? = kind {return v}
      return Symbolic_Pb_PathAction.Create()
    }
    set {kind = .create(newValue)}
  }

  var delete: Symbolic_Pb_PathAction.Delete {
    get {
      if case .delete(let v)? = kind {return v}
      return Symbolic_Pb_PathAction.Delete()
    }
    set {kind = .delete(newValue)}
  }

  var update: Symbolic_Pb_PathAction.Update {
    get {
      if case .update(let v)? = kind {return v}
      return Symbolic_Pb_PathAction.Update()
    }
    set {kind = .update(newValue)}
  }

  var move: Symbolic_Pb_PathAction.Move {
    get {
      if case .move(let v)? = kind {return v}
      return Symbolic_Pb_PathAction.Move()
    }
    set {kind = .move(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case create(Symbolic_Pb_PathAction.Create)
    case delete(Symbolic_Pb_PathAction.Delete)
    case update(Symbolic_Pb_PathAction.Update)
    case move(Symbolic_Pb_PathAction.Move)

  }

  struct Create: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var paths: Symbolic_Pb_Path {
      get {return _paths ?? Symbolic_Pb_Path()}
      set {_paths = newValue}
    }
    /// Returns true if `paths` has been explicitly set.
    var hasPaths: Bool {return self._paths != nil}
    /// Clears the value of `paths`. Subsequent reads from it will return its default value.
    mutating func clearPaths() {self._paths = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
    fileprivate var _paths: Symbolic_Pb_Path? = nil
  }

  struct Delete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathIds: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var kind: Symbolic_Pb_PathAction.Update.OneOf_Kind? = nil

    var addEndingNode: Symbolic_Pb_PathAction.Update.AddEndingNode {
      get {
        if case .addEndingNode(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.AddEndingNode()
      }
      set {kind = .addEndingNode(newValue)}
    }

    var splitSegment: Symbolic_Pb_PathAction.Update.SplitSegment {
      get {
        if case .splitSegment(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.SplitSegment()
      }
      set {kind = .splitSegment(newValue)}
    }

    var deleteNodes: Symbolic_Pb_PathAction.Update.DeleteNodes {
      get {
        if case .deleteNodes(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.DeleteNodes()
      }
      set {kind = .deleteNodes(newValue)}
    }

    var updateNode: Symbolic_Pb_PathAction.Update.UpdateNode {
      get {
        if case .updateNode(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.UpdateNode()
      }
      set {kind = .updateNode(newValue)}
    }

    var updateSegment: Symbolic_Pb_PathAction.Update.UpdateSegment {
      get {
        if case .updateSegment(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.UpdateSegment()
      }
      set {kind = .updateSegment(newValue)}
    }

    var moveNodes: Symbolic_Pb_PathAction.Update.MoveNodes {
      get {
        if case .moveNodes(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.MoveNodes()
      }
      set {kind = .moveNodes(newValue)}
    }

    var moveNodeControl: Symbolic_Pb_PathAction.Update.MoveNodeControl {
      get {
        if case .moveNodeControl(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.MoveNodeControl()
      }
      set {kind = .moveNodeControl(newValue)}
    }

    var merge: Symbolic_Pb_PathAction.Update.Merge {
      get {
        if case .merge(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.Merge()
      }
      set {kind = .merge(newValue)}
    }

    var split: Symbolic_Pb_PathAction.Update.Split {
      get {
        if case .split(let v)? = kind {return v}
        return Symbolic_Pb_PathAction.Update.Split()
      }
      set {kind = .split(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
      case addEndingNode(Symbolic_Pb_PathAction.Update.AddEndingNode)
      case splitSegment(Symbolic_Pb_PathAction.Update.SplitSegment)
      case deleteNodes(Symbolic_Pb_PathAction.Update.DeleteNodes)
      case updateNode(Symbolic_Pb_PathAction.Update.UpdateNode)
      case updateSegment(Symbolic_Pb_PathAction.Update.UpdateSegment)
      case moveNodes(Symbolic_Pb_PathAction.Update.MoveNodes)
      case moveNodeControl(Symbolic_Pb_PathAction.Update.MoveNodeControl)
      case merge(Symbolic_Pb_PathAction.Update.Merge)
      case split(Symbolic_Pb_PathAction.Update.Split)

    }

    struct AddEndingNode: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var endingNodeID: Symbolic_Pb_UUID {
        get {return _endingNodeID ?? Symbolic_Pb_UUID()}
        set {_endingNodeID = newValue}
      }
      /// Returns true if `endingNodeID` has been explicitly set.
      var hasEndingNodeID: Bool {return self._endingNodeID != nil}
      /// Clears the value of `endingNodeID`. Subsequent reads from it will return its default value.
      mutating func clearEndingNodeID() {self._endingNodeID = nil}

      var newNodeID: Symbolic_Pb_UUID {
        get {return _newNodeID ?? Symbolic_Pb_UUID()}
        set {_newNodeID = newValue}
      }
      /// Returns true if `newNodeID` has been explicitly set.
      var hasNewNodeID: Bool {return self._newNodeID != nil}
      /// Clears the value of `newNodeID`. Subsequent reads from it will return its default value.
      mutating func clearNewNodeID() {self._newNodeID = nil}

      var offset: Symbolic_Pb_Vector2 {
        get {return _offset ?? Symbolic_Pb_Vector2()}
        set {_offset = newValue}
      }
      /// Returns true if `offset` has been explicitly set.
      var hasOffset: Bool {return self._offset != nil}
      /// Clears the value of `offset`. Subsequent reads from it will return its default value.
      mutating func clearOffset() {self._offset = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _endingNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _newNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _offset: Symbolic_Pb_Vector2? = nil
    }

    struct SplitSegment: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var fromNodeID: Symbolic_Pb_UUID {
        get {return _fromNodeID ?? Symbolic_Pb_UUID()}
        set {_fromNodeID = newValue}
      }
      /// Returns true if `fromNodeID` has been explicitly set.
      var hasFromNodeID: Bool {return self._fromNodeID != nil}
      /// Clears the value of `fromNodeID`. Subsequent reads from it will return its default value.
      mutating func clearFromNodeID() {self._fromNodeID = nil}

      var paramT: Double = 0

      var newNodeID: Symbolic_Pb_UUID {
        get {return _newNodeID ?? Symbolic_Pb_UUID()}
        set {_newNodeID = newValue}
      }
      /// Returns true if `newNodeID` has been explicitly set.
      var hasNewNodeID: Bool {return self._newNodeID != nil}
      /// Clears the value of `newNodeID`. Subsequent reads from it will return its default value.
      mutating func clearNewNodeID() {self._newNodeID = nil}

      var offset: Symbolic_Pb_Vector2 {
        get {return _offset ?? Symbolic_Pb_Vector2()}
        set {_offset = newValue}
      }
      /// Returns true if `offset` has been explicitly set.
      var hasOffset: Bool {return self._offset != nil}
      /// Clears the value of `offset`. Subsequent reads from it will return its default value.
      mutating func clearOffset() {self._offset = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _fromNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _newNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _offset: Symbolic_Pb_Vector2? = nil
    }

    struct DeleteNodes: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeIds: [Symbolic_Pb_UUID] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct UpdateNode: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeID: Symbolic_Pb_UUID {
        get {return _nodeID ?? Symbolic_Pb_UUID()}
        set {_nodeID = newValue}
      }
      /// Returns true if `nodeID` has been explicitly set.
      var hasNodeID: Bool {return self._nodeID != nil}
      /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
      mutating func clearNodeID() {self._nodeID = nil}

      var node: Symbolic_Pb_PathNode {
        get {return _node ?? Symbolic_Pb_PathNode()}
        set {_node = newValue}
      }
      /// Returns true if `node` has been explicitly set.
      var hasNode: Bool {return self._node != nil}
      /// Clears the value of `node`. Subsequent reads from it will return its default value.
      mutating func clearNode() {self._node = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _node: Symbolic_Pb_PathNode? = nil
    }

    struct UpdateSegment: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var fromNodeID: Symbolic_Pb_UUID {
        get {return _fromNodeID ?? Symbolic_Pb_UUID()}
        set {_fromNodeID = newValue}
      }
      /// Returns true if `fromNodeID` has been explicitly set.
      var hasFromNodeID: Bool {return self._fromNodeID != nil}
      /// Clears the value of `fromNodeID`. Subsequent reads from it will return its default value.
      mutating func clearFromNodeID() {self._fromNodeID = nil}

      var segment: Symbolic_Pb_PathSegment {
        get {return _segment ?? Symbolic_Pb_PathSegment()}
        set {_segment = newValue}
      }
      /// Returns true if `segment` has been explicitly set.
      var hasSegment: Bool {return self._segment != nil}
      /// Clears the value of `segment`. Subsequent reads from it will return its default value.
      mutating func clearSegment() {self._segment = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _fromNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _segment: Symbolic_Pb_PathSegment? = nil
    }

    struct MoveNodes: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeIds: [Symbolic_Pb_UUID] = []

      var offset: Symbolic_Pb_Vector2 {
        get {return _offset ?? Symbolic_Pb_Vector2()}
        set {_offset = newValue}
      }
      /// Returns true if `offset` has been explicitly set.
      var hasOffset: Bool {return self._offset != nil}
      /// Clears the value of `offset`. Subsequent reads from it will return its default value.
      mutating func clearOffset() {self._offset = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _offset: Symbolic_Pb_Vector2? = nil
    }

    struct MoveNodeControl: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeID: Symbolic_Pb_UUID {
        get {return _nodeID ?? Symbolic_Pb_UUID()}
        set {_nodeID = newValue}
      }
      /// Returns true if `nodeID` has been explicitly set.
      var hasNodeID: Bool {return self._nodeID != nil}
      /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
      mutating func clearNodeID() {self._nodeID = nil}

      var controlType: Symbolic_Pb_PathNodeControlType = .cubicIn

      var offset: Symbolic_Pb_Vector2 {
        get {return _offset ?? Symbolic_Pb_Vector2()}
        set {_offset = newValue}
      }
      /// Returns true if `offset` has been explicitly set.
      var hasOffset: Bool {return self._offset != nil}
      /// Clears the value of `offset`. Subsequent reads from it will return its default value.
      mutating func clearOffset() {self._offset = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _offset: Symbolic_Pb_Vector2? = nil
    }

    struct Merge: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var endingNodeID: Symbolic_Pb_UUID {
        get {return _endingNodeID ?? Symbolic_Pb_UUID()}
        set {_endingNodeID = newValue}
      }
      /// Returns true if `endingNodeID` has been explicitly set.
      var hasEndingNodeID: Bool {return self._endingNodeID != nil}
      /// Clears the value of `endingNodeID`. Subsequent reads from it will return its default value.
      mutating func clearEndingNodeID() {self._endingNodeID = nil}

      var mergedPathID: Symbolic_Pb_UUID {
        get {return _mergedPathID ?? Symbolic_Pb_UUID()}
        set {_mergedPathID = newValue}
      }
      /// Returns true if `mergedPathID` has been explicitly set.
      var hasMergedPathID: Bool {return self._mergedPathID != nil}
      /// Clears the value of `mergedPathID`. Subsequent reads from it will return its default value.
      mutating func clearMergedPathID() {self._mergedPathID = nil}

      var mergedEndingNodeID: Symbolic_Pb_UUID {
        get {return _mergedEndingNodeID ?? Symbolic_Pb_UUID()}
        set {_mergedEndingNodeID = newValue}
      }
      /// Returns true if `mergedEndingNodeID` has been explicitly set.
      var hasMergedEndingNodeID: Bool {return self._mergedEndingNodeID != nil}
      /// Clears the value of `mergedEndingNodeID`. Subsequent reads from it will return its default value.
      mutating func clearMergedEndingNodeID() {self._mergedEndingNodeID = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _endingNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _mergedPathID: Symbolic_Pb_UUID? = nil
      fileprivate var _mergedEndingNodeID: Symbolic_Pb_UUID? = nil
    }

    struct Split: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeID: Symbolic_Pb_UUID {
        get {return _nodeID ?? Symbolic_Pb_UUID()}
        set {_nodeID = newValue}
      }
      /// Returns true if `nodeID` has been explicitly set.
      var hasNodeID: Bool {return self._nodeID != nil}
      /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
      mutating func clearNodeID() {self._nodeID = nil}

      var newPathID: Symbolic_Pb_UUID {
        get {return _newPathID ?? Symbolic_Pb_UUID()}
        set {_newPathID = newValue}
      }
      /// Returns true if `newPathID` has been explicitly set.
      var hasNewPathID: Bool {return self._newPathID != nil}
      /// Clears the value of `newPathID`. Subsequent reads from it will return its default value.
      mutating func clearNewPathID() {self._newPathID = nil}

      var newNodeID: Symbolic_Pb_UUID {
        get {return _newNodeID ?? Symbolic_Pb_UUID()}
        set {_newNodeID = newValue}
      }
      /// Returns true if `newNodeID` has been explicitly set.
      var hasNewNodeID: Bool {return self._newNodeID != nil}
      /// Clears the value of `newNodeID`. Subsequent reads from it will return its default value.
      mutating func clearNewNodeID() {self._newNodeID = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _newPathID: Symbolic_Pb_UUID? = nil
      fileprivate var _newNodeID: Symbolic_Pb_UUID? = nil
    }

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
  }

  struct Move: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathIds: [Symbolic_Pb_UUID] = []

    var offset: Symbolic_Pb_Vector2 {
      get {return _offset ?? Symbolic_Pb_Vector2()}
      set {_offset = newValue}
    }
    /// Returns true if `offset` has been explicitly set.
    var hasOffset: Bool {return self._offset != nil}
    /// Clears the value of `offset`. Subsequent reads from it will return its default value.
    mutating func clearOffset() {self._offset = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _offset: Symbolic_Pb_Vector2? = nil
  }

  init() {}
}

struct Symbolic_Pb_PathPropertyAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_PathPropertyAction.OneOf_Kind? = nil

  var update: Symbolic_Pb_PathPropertyAction.Update {
    get {
      if case .update(let v)? = kind {return v}
      return Symbolic_Pb_PathPropertyAction.Update()
    }
    set {kind = .update(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case update(Symbolic_Pb_PathPropertyAction.Update)

  }

  struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var kind: Symbolic_Pb_PathPropertyAction.Update.OneOf_Kind? = nil

    var setName: Symbolic_Pb_PathPropertyAction.Update.SetName {
      get {
        if case .setName(let v)? = kind {return v}
        return Symbolic_Pb_PathPropertyAction.Update.SetName()
      }
      set {kind = .setName(newValue)}
    }

    var setNodeType: Symbolic_Pb_PathPropertyAction.Update.SetNodeType {
      get {
        if case .setNodeType(let v)? = kind {return v}
        return Symbolic_Pb_PathPropertyAction.Update.SetNodeType()
      }
      set {kind = .setNodeType(newValue)}
    }

    var setSegmentType: Symbolic_Pb_PathPropertyAction.Update.SetSegmentType {
      get {
        if case .setSegmentType(let v)? = kind {return v}
        return Symbolic_Pb_PathPropertyAction.Update.SetSegmentType()
      }
      set {kind = .setSegmentType(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
      case setName(Symbolic_Pb_PathPropertyAction.Update.SetName)
      case setNodeType(Symbolic_Pb_PathPropertyAction.Update.SetNodeType)
      case setSegmentType(Symbolic_Pb_PathPropertyAction.Update.SetSegmentType)

    }

    struct SetName: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String {
        get {return _name ?? String()}
        set {_name = newValue}
      }
      /// Returns true if `name` has been explicitly set.
      var hasName: Bool {return self._name != nil}
      /// Clears the value of `name`. Subsequent reads from it will return its default value.
      mutating func clearName() {self._name = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _name: String? = nil
    }

    struct SetNodeType: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeIds: [Symbolic_Pb_UUID] = []

      var nodeType: Symbolic_Pb_PathNodeType {
        get {return _nodeType ?? .corner}
        set {_nodeType = newValue}
      }
      /// Returns true if `nodeType` has been explicitly set.
      var hasNodeType: Bool {return self._nodeType != nil}
      /// Clears the value of `nodeType`. Subsequent reads from it will return its default value.
      mutating func clearNodeType() {self._nodeType = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeType: Symbolic_Pb_PathNodeType? = nil
    }

    struct SetSegmentType: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var fromNodeIds: [Symbolic_Pb_UUID] = []

      var segmentType: Symbolic_Pb_PathSegmentType {
        get {return _segmentType ?? .cubic}
        set {_segmentType = newValue}
      }
      /// Returns true if `segmentType` has been explicitly set.
      var hasSegmentType: Bool {return self._segmentType != nil}
      /// Clears the value of `segmentType`. Subsequent reads from it will return its default value.
      mutating func clearSegmentType() {self._segmentType = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _segmentType: Symbolic_Pb_PathSegmentType? = nil
    }

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
  }

  init() {}
}

struct Symbolic_Pb_DocumentAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_DocumentAction.OneOf_Kind? = nil

  var itemAction: Symbolic_Pb_ItemAction {
    get {
      if case .itemAction(let v)? = kind {return v}
      return Symbolic_Pb_ItemAction()
    }
    set {kind = .itemAction(newValue)}
  }

  var pathAction: Symbolic_Pb_PathAction {
    get {
      if case .pathAction(let v)? = kind {return v}
      return Symbolic_Pb_PathAction()
    }
    set {kind = .pathAction(newValue)}
  }

  var pathPropertyAction: Symbolic_Pb_PathPropertyAction {
    get {
      if case .pathPropertyAction(let v)? = kind {return v}
      return Symbolic_Pb_PathPropertyAction()
    }
    set {kind = .pathPropertyAction(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case itemAction(Symbolic_Pb_ItemAction)
    case pathAction(Symbolic_Pb_PathAction)
    case pathPropertyAction(Symbolic_Pb_PathPropertyAction)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "symbolic.pb"

extension Symbolic_Pb_ItemAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ItemAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "group"),
    102: .same(proto: "ungroup"),
    103: .same(proto: "reorder"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_ItemAction.Group?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .group(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .group(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_ItemAction.Ungroup?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .ungroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .ungroup(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_ItemAction.Reorder?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .reorder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .reorder(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .group?: try {
      guard case .group(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .ungroup?: try {
      guard case .ungroup(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .reorder?: try {
      guard case .reorder(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction, rhs: Symbolic_Pb_ItemAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemAction.Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemAction.protoMessageName + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .standard(proto: "in_group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inGroupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inGroupID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction.Group, rhs: Symbolic_Pb_ItemAction.Group) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs._inGroupID != rhs._inGroupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemAction.Ungroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemAction.protoMessageName + ".Ungroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction.Ungroup, rhs: Symbolic_Pb_ItemAction.Ungroup) -> Bool {
    if lhs.groupIds != rhs.groupIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemAction.Reorder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemAction.protoMessageName + ".Reorder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
    2: .standard(proto: "in_group_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inGroupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    try { if let v = self._inGroupID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemAction.Reorder, rhs: Symbolic_Pb_ItemAction.Reorder) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs._inGroupID != rhs._inGroupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "create"),
    102: .same(proto: "delete"),
    103: .same(proto: "update"),
    104: .same(proto: "move"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathAction.Create?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .create(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathAction.Delete?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .delete(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathAction.Update?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .update(v)
        }
      }()
      case 104: try {
        var v: Symbolic_Pb_PathAction.Move?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .move(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .move(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .create?: try {
      guard case .create(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .update?: try {
      guard case .update(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .move?: try {
      guard case .move(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction, rhs: Symbolic_Pb_PathAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.protoMessageName + ".Create"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    2: .same(proto: "paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._paths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._paths {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Create, rhs: Symbolic_Pb_PathAction.Create) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs._paths != rhs._paths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.protoMessageName + ".Delete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pathIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Delete, rhs: Symbolic_Pb_PathAction.Delete) -> Bool {
    if lhs.pathIds != rhs.pathIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.protoMessageName + ".Update"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    101: .standard(proto: "add_ending_node"),
    102: .standard(proto: "split_segment"),
    103: .standard(proto: "delete_nodes"),
    104: .standard(proto: "update_node"),
    105: .standard(proto: "update_segment"),
    106: .standard(proto: "move_nodes"),
    107: .standard(proto: "move_node_control"),
    108: .same(proto: "merge"),
    109: .same(proto: "split"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 101: try {
        var v: Symbolic_Pb_PathAction.Update.AddEndingNode?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .addEndingNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .addEndingNode(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathAction.Update.SplitSegment?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .splitSegment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .splitSegment(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathAction.Update.DeleteNodes?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .deleteNodes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .deleteNodes(v)
        }
      }()
      case 104: try {
        var v: Symbolic_Pb_PathAction.Update.UpdateNode?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .updateNode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .updateNode(v)
        }
      }()
      case 105: try {
        var v: Symbolic_Pb_PathAction.Update.UpdateSegment?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .updateSegment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .updateSegment(v)
        }
      }()
      case 106: try {
        var v: Symbolic_Pb_PathAction.Update.MoveNodes?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .moveNodes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .moveNodes(v)
        }
      }()
      case 107: try {
        var v: Symbolic_Pb_PathAction.Update.MoveNodeControl?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .moveNodeControl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .moveNodeControl(v)
        }
      }()
      case 108: try {
        var v: Symbolic_Pb_PathAction.Update.Merge?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .merge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .merge(v)
        }
      }()
      case 109: try {
        var v: Symbolic_Pb_PathAction.Update.Split?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .split(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .split(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.kind {
    case .addEndingNode?: try {
      guard case .addEndingNode(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .splitSegment?: try {
      guard case .splitSegment(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .deleteNodes?: try {
      guard case .deleteNodes(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .updateNode?: try {
      guard case .updateNode(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .updateSegment?: try {
      guard case .updateSegment(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .moveNodes?: try {
      guard case .moveNodes(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .moveNodeControl?: try {
      guard case .moveNodeControl(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .merge?: try {
      guard case .merge(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .split?: try {
      guard case .split(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update, rhs: Symbolic_Pb_PathAction.Update) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.AddEndingNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".AddEndingNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ending_node_id"),
    2: .standard(proto: "new_node_id"),
    3: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endingNodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newNodeID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.AddEndingNode, rhs: Symbolic_Pb_PathAction.Update.AddEndingNode) -> Bool {
    if lhs._endingNodeID != rhs._endingNodeID {return false}
    if lhs._newNodeID != rhs._newNodeID {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.SplitSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".SplitSegment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node_id"),
    2: .same(proto: "paramT"),
    3: .standard(proto: "new_node_id"),
    4: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fromNodeID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.paramT) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newNodeID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fromNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.paramT.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.paramT, fieldNumber: 2)
    }
    try { if let v = self._newNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.SplitSegment, rhs: Symbolic_Pb_PathAction.Update.SplitSegment) -> Bool {
    if lhs._fromNodeID != rhs._fromNodeID {return false}
    if lhs.paramT != rhs.paramT {return false}
    if lhs._newNodeID != rhs._newNodeID {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.DeleteNodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".DeleteNodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.DeleteNodes, rhs: Symbolic_Pb_PathAction.Update.DeleteNodes) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.UpdateNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".UpdateNode"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.UpdateNode, rhs: Symbolic_Pb_PathAction.Update.UpdateNode) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.UpdateSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".UpdateSegment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node_id"),
    2: .same(proto: "segment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fromNodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._segment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fromNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._segment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.UpdateSegment, rhs: Symbolic_Pb_PathAction.Update.UpdateSegment) -> Bool {
    if lhs._fromNodeID != rhs._fromNodeID {return false}
    if lhs._segment != rhs._segment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.MoveNodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".MoveNodes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
    2: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.MoveNodes, rhs: Symbolic_Pb_PathAction.Update.MoveNodes) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.MoveNodeControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".MoveNodeControl"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "control_type"),
    3: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.controlType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.controlType != .cubicIn {
      try visitor.visitSingularEnumField(value: self.controlType, fieldNumber: 2)
    }
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.MoveNodeControl, rhs: Symbolic_Pb_PathAction.Update.MoveNodeControl) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs.controlType != rhs.controlType {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.Merge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".Merge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ending_node_id"),
    2: .standard(proto: "merged_path_id"),
    3: .standard(proto: "merged_ending_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endingNodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mergedPathID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mergedEndingNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mergedPathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mergedEndingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.Merge, rhs: Symbolic_Pb_PathAction.Update.Merge) -> Bool {
    if lhs._endingNodeID != rhs._endingNodeID {return false}
    if lhs._mergedPathID != rhs._mergedPathID {return false}
    if lhs._mergedEndingNodeID != rhs._mergedEndingNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Update.Split: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.Update.protoMessageName + ".Split"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "new_path_id"),
    3: .standard(proto: "new_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newPathID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newPathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Update.Split, rhs: Symbolic_Pb_PathAction.Update.Split) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._newPathID != rhs._newPathID {return false}
    if lhs._newNodeID != rhs._newNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathAction.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathAction.protoMessageName + ".Move"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_ids"),
    2: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pathIds) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pathIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathIds, fieldNumber: 1)
    }
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathAction.Move, rhs: Symbolic_Pb_PathAction.Move) -> Bool {
    if lhs.pathIds != rhs.pathIds {return false}
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathPropertyAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathPropertyAction.Update?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .update(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .update(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyAction, rhs: Symbolic_Pb_PathPropertyAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyAction.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathPropertyAction.protoMessageName + ".Update"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    101: .standard(proto: "set_name"),
    102: .standard(proto: "set_node_type"),
    103: .standard(proto: "set_segment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 101: try {
        var v: Symbolic_Pb_PathPropertyAction.Update.SetName?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setName(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathPropertyAction.Update.SetNodeType?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setNodeType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setNodeType(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathPropertyAction.Update.SetSegmentType?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setSegmentType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setSegmentType(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.kind {
    case .setName?: try {
      guard case .setName(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .setNodeType?: try {
      guard case .setNodeType(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .setSegmentType?: try {
      guard case .setSegmentType(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyAction.Update, rhs: Symbolic_Pb_PathPropertyAction.Update) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyAction.Update.SetName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathPropertyAction.Update.protoMessageName + ".SetName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyAction.Update.SetName, rhs: Symbolic_Pb_PathPropertyAction.Update.SetName) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyAction.Update.SetNodeType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathPropertyAction.Update.protoMessageName + ".SetNodeType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
    2: .standard(proto: "node_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._nodeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    try { if let v = self._nodeType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyAction.Update.SetNodeType, rhs: Symbolic_Pb_PathPropertyAction.Update.SetNodeType) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs._nodeType != rhs._nodeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyAction.Update.SetSegmentType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathPropertyAction.Update.protoMessageName + ".SetSegmentType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node_ids"),
    2: .standard(proto: "segment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fromNodeIds) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._segmentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fromNodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fromNodeIds, fieldNumber: 1)
    }
    try { if let v = self._segmentType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyAction.Update.SetSegmentType, rhs: Symbolic_Pb_PathPropertyAction.Update.SetSegmentType) -> Bool {
    if lhs.fromNodeIds != rhs.fromNodeIds {return false}
    if lhs._segmentType != rhs._segmentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_DocumentAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .standard(proto: "item_action"),
    102: .standard(proto: "path_action"),
    103: .standard(proto: "path_property_action"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_ItemAction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .itemAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .itemAction(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathAction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .pathAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .pathAction(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathPropertyAction?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .pathPropertyAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .pathPropertyAction(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .itemAction?: try {
      guard case .itemAction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .pathAction?: try {
      guard case .pathAction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .pathPropertyAction?: try {
      guard case .pathPropertyAction(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_DocumentAction, rhs: Symbolic_Pb_DocumentAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
