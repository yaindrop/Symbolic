// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protobuf/document-event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Symbolic_Pb_ItemEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_ItemEvent.OneOf_Kind? = nil

  var setMembers: Symbolic_Pb_ItemEvent.SetMembers {
    get {
      if case .setMembers(let v)? = kind {return v}
      return Symbolic_Pb_ItemEvent.SetMembers()
    }
    set {kind = .setMembers(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case setMembers(Symbolic_Pb_ItemEvent.SetMembers)

  }

  struct SetMembers: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// null group_id means root
    var groupID: Symbolic_Pb_UUID {
      get {return _groupID ?? Symbolic_Pb_UUID()}
      set {_groupID = newValue}
    }
    /// Returns true if `groupID` has been explicitly set.
    var hasGroupID: Bool {return self._groupID != nil}
    /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
    mutating func clearGroupID() {self._groupID = nil}

    var members: [Symbolic_Pb_UUID] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _groupID: Symbolic_Pb_UUID? = nil
  }

  init() {}
}

struct Symbolic_Pb_PathEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_PathEvent.OneOf_Kind? = nil

  var create: Symbolic_Pb_PathEvent.Create {
    get {
      if case .create(let v)? = kind {return v}
      return Symbolic_Pb_PathEvent.Create()
    }
    set {kind = .create(newValue)}
  }

  var delete: Symbolic_Pb_PathEvent.Delete {
    get {
      if case .delete(let v)? = kind {return v}
      return Symbolic_Pb_PathEvent.Delete()
    }
    set {kind = .delete(newValue)}
  }

  var update: Symbolic_Pb_PathEvent.Update {
    get {
      if case .update(let v)? = kind {return v}
      return Symbolic_Pb_PathEvent.Update()
    }
    set {kind = .update(newValue)}
  }

  var merge: Symbolic_Pb_PathEvent.Merge {
    get {
      if case .merge(let v)? = kind {return v}
      return Symbolic_Pb_PathEvent.Merge()
    }
    set {kind = .merge(newValue)}
  }

  var split: Symbolic_Pb_PathEvent.Split {
    get {
      if case .split(let v)? = kind {return v}
      return Symbolic_Pb_PathEvent.Split()
    }
    set {kind = .split(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case create(Symbolic_Pb_PathEvent.Create)
    case delete(Symbolic_Pb_PathEvent.Delete)
    case update(Symbolic_Pb_PathEvent.Update)
    case merge(Symbolic_Pb_PathEvent.Merge)
    case split(Symbolic_Pb_PathEvent.Split)

  }

  struct Create: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var path: Symbolic_Pb_Path {
      get {return _path ?? Symbolic_Pb_Path()}
      set {_path = newValue}
    }
    /// Returns true if `path` has been explicitly set.
    var hasPath: Bool {return self._path != nil}
    /// Clears the value of `path`. Subsequent reads from it will return its default value.
    mutating func clearPath() {self._path = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
    fileprivate var _path: Symbolic_Pb_Path? = nil
  }

  struct Delete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
  }

  struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var kinds: [Symbolic_Pb_PathEvent.Update.Kind] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Move: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var offset: Symbolic_Pb_Vector2 {
        get {return _offset ?? Symbolic_Pb_Vector2()}
        set {_offset = newValue}
      }
      /// Returns true if `offset` has been explicitly set.
      var hasOffset: Bool {return self._offset != nil}
      /// Clears the value of `offset`. Subsequent reads from it will return its default value.
      mutating func clearOffset() {self._offset = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _offset: Symbolic_Pb_Vector2? = nil
    }

    struct NodeCreate: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var prevNodeID: Symbolic_Pb_UUID {
        get {return _prevNodeID ?? Symbolic_Pb_UUID()}
        set {_prevNodeID = newValue}
      }
      /// Returns true if `prevNodeID` has been explicitly set.
      var hasPrevNodeID: Bool {return self._prevNodeID != nil}
      /// Clears the value of `prevNodeID`. Subsequent reads from it will return its default value.
      mutating func clearPrevNodeID() {self._prevNodeID = nil}

      var nodeID: Symbolic_Pb_UUID {
        get {return _nodeID ?? Symbolic_Pb_UUID()}
        set {_nodeID = newValue}
      }
      /// Returns true if `nodeID` has been explicitly set.
      var hasNodeID: Bool {return self._nodeID != nil}
      /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
      mutating func clearNodeID() {self._nodeID = nil}

      var node: Symbolic_Pb_PathNode {
        get {return _node ?? Symbolic_Pb_PathNode()}
        set {_node = newValue}
      }
      /// Returns true if `node` has been explicitly set.
      var hasNode: Bool {return self._node != nil}
      /// Clears the value of `node`. Subsequent reads from it will return its default value.
      mutating func clearNode() {self._node = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _prevNodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _node: Symbolic_Pb_PathNode? = nil
    }

    struct NodeDelete: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeID: Symbolic_Pb_UUID {
        get {return _nodeID ?? Symbolic_Pb_UUID()}
        set {_nodeID = newValue}
      }
      /// Returns true if `nodeID` has been explicitly set.
      var hasNodeID: Bool {return self._nodeID != nil}
      /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
      mutating func clearNodeID() {self._nodeID = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
    }

    struct NodeUpdate: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeID: Symbolic_Pb_UUID {
        get {return _nodeID ?? Symbolic_Pb_UUID()}
        set {_nodeID = newValue}
      }
      /// Returns true if `nodeID` has been explicitly set.
      var hasNodeID: Bool {return self._nodeID != nil}
      /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
      mutating func clearNodeID() {self._nodeID = nil}

      var node: Symbolic_Pb_PathNode {
        get {return _node ?? Symbolic_Pb_PathNode()}
        set {_node = newValue}
      }
      /// Returns true if `node` has been explicitly set.
      var hasNode: Bool {return self._node != nil}
      /// Clears the value of `node`. Subsequent reads from it will return its default value.
      mutating func clearNode() {self._node = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
      fileprivate var _node: Symbolic_Pb_PathNode? = nil
    }

    struct Kind: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var kind: Symbolic_Pb_PathEvent.Update.Kind.OneOf_Kind? = nil

      var move: Symbolic_Pb_PathEvent.Update.Move {
        get {
          if case .move(let v)? = kind {return v}
          return Symbolic_Pb_PathEvent.Update.Move()
        }
        set {kind = .move(newValue)}
      }

      var nodeCreate: Symbolic_Pb_PathEvent.Update.NodeCreate {
        get {
          if case .nodeCreate(let v)? = kind {return v}
          return Symbolic_Pb_PathEvent.Update.NodeCreate()
        }
        set {kind = .nodeCreate(newValue)}
      }

      var nodeDelete: Symbolic_Pb_PathEvent.Update.NodeDelete {
        get {
          if case .nodeDelete(let v)? = kind {return v}
          return Symbolic_Pb_PathEvent.Update.NodeDelete()
        }
        set {kind = .nodeDelete(newValue)}
      }

      var nodeUpdate: Symbolic_Pb_PathEvent.Update.NodeUpdate {
        get {
          if case .nodeUpdate(let v)? = kind {return v}
          return Symbolic_Pb_PathEvent.Update.NodeUpdate()
        }
        set {kind = .nodeUpdate(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Kind: Equatable, Sendable {
        case move(Symbolic_Pb_PathEvent.Update.Move)
        case nodeCreate(Symbolic_Pb_PathEvent.Update.NodeCreate)
        case nodeDelete(Symbolic_Pb_PathEvent.Update.NodeDelete)
        case nodeUpdate(Symbolic_Pb_PathEvent.Update.NodeUpdate)

      }

      init() {}
    }

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
  }

  struct Merge: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var endingNodeID: Symbolic_Pb_UUID {
      get {return _endingNodeID ?? Symbolic_Pb_UUID()}
      set {_endingNodeID = newValue}
    }
    /// Returns true if `endingNodeID` has been explicitly set.
    var hasEndingNodeID: Bool {return self._endingNodeID != nil}
    /// Clears the value of `endingNodeID`. Subsequent reads from it will return its default value.
    mutating func clearEndingNodeID() {self._endingNodeID = nil}

    var mergedPathID: Symbolic_Pb_UUID {
      get {return _mergedPathID ?? Symbolic_Pb_UUID()}
      set {_mergedPathID = newValue}
    }
    /// Returns true if `mergedPathID` has been explicitly set.
    var hasMergedPathID: Bool {return self._mergedPathID != nil}
    /// Clears the value of `mergedPathID`. Subsequent reads from it will return its default value.
    mutating func clearMergedPathID() {self._mergedPathID = nil}

    var mergedEndingNodeID: Symbolic_Pb_UUID {
      get {return _mergedEndingNodeID ?? Symbolic_Pb_UUID()}
      set {_mergedEndingNodeID = newValue}
    }
    /// Returns true if `mergedEndingNodeID` has been explicitly set.
    var hasMergedEndingNodeID: Bool {return self._mergedEndingNodeID != nil}
    /// Clears the value of `mergedEndingNodeID`. Subsequent reads from it will return its default value.
    mutating func clearMergedEndingNodeID() {self._mergedEndingNodeID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
    fileprivate var _endingNodeID: Symbolic_Pb_UUID? = nil
    fileprivate var _mergedPathID: Symbolic_Pb_UUID? = nil
    fileprivate var _mergedEndingNodeID: Symbolic_Pb_UUID? = nil
  }

  struct Split: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var nodeID: Symbolic_Pb_UUID {
      get {return _nodeID ?? Symbolic_Pb_UUID()}
      set {_nodeID = newValue}
    }
    /// Returns true if `nodeID` has been explicitly set.
    var hasNodeID: Bool {return self._nodeID != nil}
    /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
    mutating func clearNodeID() {self._nodeID = nil}

    var newPathID: Symbolic_Pb_UUID {
      get {return _newPathID ?? Symbolic_Pb_UUID()}
      set {_newPathID = newValue}
    }
    /// Returns true if `newPathID` has been explicitly set.
    var hasNewPathID: Bool {return self._newPathID != nil}
    /// Clears the value of `newPathID`. Subsequent reads from it will return its default value.
    mutating func clearNewPathID() {self._newPathID = nil}

    var newNodeID: Symbolic_Pb_UUID {
      get {return _newNodeID ?? Symbolic_Pb_UUID()}
      set {_newNodeID = newValue}
    }
    /// Returns true if `newNodeID` has been explicitly set.
    var hasNewNodeID: Bool {return self._newNodeID != nil}
    /// Clears the value of `newNodeID`. Subsequent reads from it will return its default value.
    mutating func clearNewNodeID() {self._newNodeID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
    fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
    fileprivate var _newPathID: Symbolic_Pb_UUID? = nil
    fileprivate var _newNodeID: Symbolic_Pb_UUID? = nil
  }

  init() {}
}

struct Symbolic_Pb_PathPropertyEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var kind: Symbolic_Pb_PathPropertyEvent.OneOf_Kind? = nil

  var update: Symbolic_Pb_PathPropertyEvent.Update {
    get {
      if case .update(let v)? = kind {return v}
      return Symbolic_Pb_PathPropertyEvent.Update()
    }
    set {kind = .update(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case update(Symbolic_Pb_PathPropertyEvent.Update)

  }

  struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var pathID: Symbolic_Pb_UUID {
      get {return _pathID ?? Symbolic_Pb_UUID()}
      set {_pathID = newValue}
    }
    /// Returns true if `pathID` has been explicitly set.
    var hasPathID: Bool {return self._pathID != nil}
    /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
    mutating func clearPathID() {self._pathID = nil}

    var kinds: [Symbolic_Pb_PathPropertyEvent.Update.Kind] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct SetName: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String {
        get {return _name ?? String()}
        set {_name = newValue}
      }
      /// Returns true if `name` has been explicitly set.
      var hasName: Bool {return self._name != nil}
      /// Clears the value of `name`. Subsequent reads from it will return its default value.
      mutating func clearName() {self._name = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _name: String? = nil
    }

    struct SetNodeType: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var nodeIds: [Symbolic_Pb_UUID] = []

      var nodeType: Symbolic_Pb_PathNodeType {
        get {return _nodeType ?? .corner}
        set {_nodeType = newValue}
      }
      /// Returns true if `nodeType` has been explicitly set.
      var hasNodeType: Bool {return self._nodeType != nil}
      /// Clears the value of `nodeType`. Subsequent reads from it will return its default value.
      mutating func clearNodeType() {self._nodeType = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _nodeType: Symbolic_Pb_PathNodeType? = nil
    }

    struct SetSegmentType: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var fromNodeIds: [Symbolic_Pb_UUID] = []

      var segmentType: Symbolic_Pb_PathSegmentType {
        get {return _segmentType ?? .cubic}
        set {_segmentType = newValue}
      }
      /// Returns true if `segmentType` has been explicitly set.
      var hasSegmentType: Bool {return self._segmentType != nil}
      /// Clears the value of `segmentType`. Subsequent reads from it will return its default value.
      mutating func clearSegmentType() {self._segmentType = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _segmentType: Symbolic_Pb_PathSegmentType? = nil
    }

    struct Kind: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var kind: Symbolic_Pb_PathPropertyEvent.Update.Kind.OneOf_Kind? = nil

      var setName: Symbolic_Pb_PathPropertyEvent.Update.SetName {
        get {
          if case .setName(let v)? = kind {return v}
          return Symbolic_Pb_PathPropertyEvent.Update.SetName()
        }
        set {kind = .setName(newValue)}
      }

      var setNodeType: Symbolic_Pb_PathPropertyEvent.Update.SetNodeType {
        get {
          if case .setNodeType(let v)? = kind {return v}
          return Symbolic_Pb_PathPropertyEvent.Update.SetNodeType()
        }
        set {kind = .setNodeType(newValue)}
      }

      var setSegmentType: Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType {
        get {
          if case .setSegmentType(let v)? = kind {return v}
          return Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType()
        }
        set {kind = .setSegmentType(newValue)}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum OneOf_Kind: Equatable, Sendable {
        case setName(Symbolic_Pb_PathPropertyEvent.Update.SetName)
        case setNodeType(Symbolic_Pb_PathPropertyEvent.Update.SetNodeType)
        case setSegmentType(Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType)

      }

      init() {}
    }

    init() {}

    fileprivate var _pathID: Symbolic_Pb_UUID? = nil
  }

  init() {}
}

struct Symbolic_Pb_DocumentEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Symbolic_Pb_UUID {
    get {return _id ?? Symbolic_Pb_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var kind: Symbolic_Pb_DocumentEvent.OneOf_Kind? = nil

  var single: Symbolic_Pb_DocumentEvent.Single {
    get {
      if case .single(let v)? = kind {return v}
      return Symbolic_Pb_DocumentEvent.Single()
    }
    set {kind = .single(newValue)}
  }

  var compound: Symbolic_Pb_DocumentEvent.Compound {
    get {
      if case .compound(let v)? = kind {return v}
      return Symbolic_Pb_DocumentEvent.Compound()
    }
    set {kind = .compound(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Kind: Equatable, Sendable {
    case single(Symbolic_Pb_DocumentEvent.Single)
    case compound(Symbolic_Pb_DocumentEvent.Compound)

  }

  struct Single: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Symbolic_Pb_DocumentEvent.Single.OneOf_Kind? = nil

    var itemEvent: Symbolic_Pb_ItemEvent {
      get {
        if case .itemEvent(let v)? = kind {return v}
        return Symbolic_Pb_ItemEvent()
      }
      set {kind = .itemEvent(newValue)}
    }

    var pathEvent: Symbolic_Pb_PathEvent {
      get {
        if case .pathEvent(let v)? = kind {return v}
        return Symbolic_Pb_PathEvent()
      }
      set {kind = .pathEvent(newValue)}
    }

    var pathPropertyEvent: Symbolic_Pb_PathPropertyEvent {
      get {
        if case .pathPropertyEvent(let v)? = kind {return v}
        return Symbolic_Pb_PathPropertyEvent()
      }
      set {kind = .pathPropertyEvent(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
      case itemEvent(Symbolic_Pb_ItemEvent)
      case pathEvent(Symbolic_Pb_PathEvent)
      case pathPropertyEvent(Symbolic_Pb_PathPropertyEvent)

    }

    init() {}
  }

  struct Compound: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var events: [Symbolic_Pb_DocumentEvent.Single] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _id: Symbolic_Pb_UUID? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "symbolic.pb"

extension Symbolic_Pb_ItemEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ItemEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .standard(proto: "set_members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_ItemEvent.SetMembers?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setMembers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setMembers(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .setMembers(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemEvent, rhs: Symbolic_Pb_ItemEvent) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_ItemEvent.SetMembers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_ItemEvent.protoMessageName + ".SetMembers"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "members"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_ItemEvent.SetMembers, rhs: Symbolic_Pb_ItemEvent.SetMembers) -> Bool {
    if lhs._groupID != rhs._groupID {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "create"),
    102: .same(proto: "delete"),
    103: .same(proto: "update"),
    104: .same(proto: "merge"),
    105: .same(proto: "split"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathEvent.Create?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .create(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathEvent.Delete?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .delete(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathEvent.Update?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .update(v)
        }
      }()
      case 104: try {
        var v: Symbolic_Pb_PathEvent.Merge?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .merge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .merge(v)
        }
      }()
      case 105: try {
        var v: Symbolic_Pb_PathEvent.Split?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .split(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .split(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .create?: try {
      guard case .create(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .update?: try {
      guard case .update(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .merge?: try {
      guard case .merge(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .split?: try {
      guard case .split(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent, rhs: Symbolic_Pb_PathEvent) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Create"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    2: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Create, rhs: Symbolic_Pb_PathEvent.Create) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Delete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Delete, rhs: Symbolic_Pb_PathEvent.Delete) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Update"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    2: .same(proto: "kinds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.kinds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kinds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Update, rhs: Symbolic_Pb_PathEvent.Update) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs.kinds != rhs.kinds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Update.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.Update.protoMessageName + ".Move"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._offset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Update.Move, rhs: Symbolic_Pb_PathEvent.Update.Move) -> Bool {
    if lhs._offset != rhs._offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Update.NodeCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.Update.protoMessageName + ".NodeCreate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prev_node_id"),
    2: .standard(proto: "node_id"),
    3: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._prevNodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._prevNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Update.NodeCreate, rhs: Symbolic_Pb_PathEvent.Update.NodeCreate) -> Bool {
    if lhs._prevNodeID != rhs._prevNodeID {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Update.NodeDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.Update.protoMessageName + ".NodeDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Update.NodeDelete, rhs: Symbolic_Pb_PathEvent.Update.NodeDelete) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Update.NodeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.Update.protoMessageName + ".NodeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Update.NodeUpdate, rhs: Symbolic_Pb_PathEvent.Update.NodeUpdate) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Update.Kind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.Update.protoMessageName + ".Kind"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "move"),
    102: .standard(proto: "node_create"),
    103: .standard(proto: "node_delete"),
    104: .standard(proto: "node_update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathEvent.Update.Move?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .move(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .move(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathEvent.Update.NodeCreate?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .nodeCreate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .nodeCreate(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathEvent.Update.NodeDelete?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .nodeDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .nodeDelete(v)
        }
      }()
      case 104: try {
        var v: Symbolic_Pb_PathEvent.Update.NodeUpdate?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .nodeUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .nodeUpdate(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .move?: try {
      guard case .move(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .nodeCreate?: try {
      guard case .nodeCreate(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .nodeDelete?: try {
      guard case .nodeDelete(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .nodeUpdate?: try {
      guard case .nodeUpdate(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Update.Kind, rhs: Symbolic_Pb_PathEvent.Update.Kind) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Merge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Merge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    2: .standard(proto: "ending_node_id"),
    3: .standard(proto: "merged_path_id"),
    4: .standard(proto: "merged_ending_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endingNodeID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mergedPathID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._mergedEndingNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mergedPathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mergedEndingNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Merge, rhs: Symbolic_Pb_PathEvent.Merge) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs._endingNodeID != rhs._endingNodeID {return false}
    if lhs._mergedPathID != rhs._mergedPathID {return false}
    if lhs._mergedEndingNodeID != rhs._mergedEndingNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathEvent.Split: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Split"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    2: .standard(proto: "node_id"),
    3: .standard(proto: "new_path_id"),
    4: .standard(proto: "new_node_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newPathID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newNodeID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newPathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._newNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathEvent.Split, rhs: Symbolic_Pb_PathEvent.Split) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._newPathID != rhs._newPathID {return false}
    if lhs._newNodeID != rhs._newNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PathPropertyEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .same(proto: "update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathPropertyEvent.Update?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .update(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .update(let v)? = self.kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyEvent, rhs: Symbolic_Pb_PathPropertyEvent) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyEvent.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathPropertyEvent.protoMessageName + ".Update"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    2: .same(proto: "kinds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pathID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.kinds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pathID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.kinds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.kinds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyEvent.Update, rhs: Symbolic_Pb_PathPropertyEvent.Update) -> Bool {
    if lhs._pathID != rhs._pathID {return false}
    if lhs.kinds != rhs.kinds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyEvent.Update.SetName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathPropertyEvent.Update.protoMessageName + ".SetName"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyEvent.Update.SetName, rhs: Symbolic_Pb_PathPropertyEvent.Update.SetName) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyEvent.Update.SetNodeType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathPropertyEvent.Update.protoMessageName + ".SetNodeType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_ids"),
    2: .standard(proto: "node_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodeIds) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._nodeType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodeIds, fieldNumber: 1)
    }
    try { if let v = self._nodeType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyEvent.Update.SetNodeType, rhs: Symbolic_Pb_PathPropertyEvent.Update.SetNodeType) -> Bool {
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs._nodeType != rhs._nodeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathPropertyEvent.Update.protoMessageName + ".SetSegmentType"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node_ids"),
    2: .standard(proto: "segment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fromNodeIds) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._segmentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fromNodeIds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fromNodeIds, fieldNumber: 1)
    }
    try { if let v = self._segmentType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType, rhs: Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType) -> Bool {
    if lhs.fromNodeIds != rhs.fromNodeIds {return false}
    if lhs._segmentType != rhs._segmentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_PathPropertyEvent.Update.Kind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_PathPropertyEvent.Update.protoMessageName + ".Kind"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .standard(proto: "set_name"),
    102: .standard(proto: "set_node_type"),
    103: .standard(proto: "set_segment_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_PathPropertyEvent.Update.SetName?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setName(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathPropertyEvent.Update.SetNodeType?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setNodeType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setNodeType(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .setSegmentType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .setSegmentType(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .setName?: try {
      guard case .setName(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .setNodeType?: try {
      guard case .setNodeType(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .setSegmentType?: try {
      guard case .setSegmentType(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_PathPropertyEvent.Update.Kind, rhs: Symbolic_Pb_PathPropertyEvent.Update.Kind) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_DocumentEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "time"),
    101: .same(proto: "single"),
    102: .same(proto: "compound"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 101: try {
        var v: Symbolic_Pb_DocumentEvent.Single?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .single(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .single(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_DocumentEvent.Compound?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .compound(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .compound(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.kind {
    case .single?: try {
      guard case .single(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .compound?: try {
      guard case .compound(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_DocumentEvent, rhs: Symbolic_Pb_DocumentEvent) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._time != rhs._time {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_DocumentEvent.Single: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_DocumentEvent.protoMessageName + ".Single"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    101: .standard(proto: "item_event"),
    102: .standard(proto: "path_event"),
    103: .standard(proto: "path_property_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 101: try {
        var v: Symbolic_Pb_ItemEvent?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .itemEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .itemEvent(v)
        }
      }()
      case 102: try {
        var v: Symbolic_Pb_PathEvent?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .pathEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .pathEvent(v)
        }
      }()
      case 103: try {
        var v: Symbolic_Pb_PathPropertyEvent?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .pathPropertyEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .pathPropertyEvent(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .itemEvent?: try {
      guard case .itemEvent(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .pathEvent?: try {
      guard case .pathEvent(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .pathPropertyEvent?: try {
      guard case .pathPropertyEvent(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_DocumentEvent.Single, rhs: Symbolic_Pb_DocumentEvent.Single) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Symbolic_Pb_DocumentEvent.Compound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Symbolic_Pb_DocumentEvent.protoMessageName + ".Compound"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Symbolic_Pb_DocumentEvent.Compound, rhs: Symbolic_Pb_DocumentEvent.Compound) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
