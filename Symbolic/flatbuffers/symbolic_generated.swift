// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum FB_PathEvent_Update_Kind: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case move = 1
  case nodecreate = 2
  case nodedelete = 3
  case nodeupdate = 4

  public static var max: FB_PathEvent_Update_Kind { return .nodeupdate }
  public static var min: FB_PathEvent_Update_Kind { return .none_ }
}


public enum FB_PathEvent_Kind: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case create = 1
  case delete = 2
  case update = 3

  public static var max: FB_PathEvent_Kind { return .update }
  public static var min: FB_PathEvent_Kind { return .none_ }
}


public enum FB_DocumentEvent_Kind: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case fbPathevent = 1

  public static var max: FB_DocumentEvent_Kind { return .fbPathevent }
  public static var min: FB_DocumentEvent_Kind { return .none_ }
}


public struct FB_UUID: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }

  private var _u0: UInt8
  private var _u1: UInt8
  private var _u2: UInt8
  private var _u3: UInt8
  private var _u4: UInt8
  private var _u5: UInt8
  private var _u6: UInt8
  private var _u7: UInt8
  private var _u8: UInt8
  private var _u9: UInt8
  private var _u10: UInt8
  private var _u11: UInt8
  private var _u12: UInt8
  private var _u13: UInt8
  private var _u14: UInt8
  private var _u15: UInt8

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _u0 = _accessor.readBuffer(of: UInt8.self, at: 0)
    _u1 = _accessor.readBuffer(of: UInt8.self, at: 1)
    _u2 = _accessor.readBuffer(of: UInt8.self, at: 2)
    _u3 = _accessor.readBuffer(of: UInt8.self, at: 3)
    _u4 = _accessor.readBuffer(of: UInt8.self, at: 4)
    _u5 = _accessor.readBuffer(of: UInt8.self, at: 5)
    _u6 = _accessor.readBuffer(of: UInt8.self, at: 6)
    _u7 = _accessor.readBuffer(of: UInt8.self, at: 7)
    _u8 = _accessor.readBuffer(of: UInt8.self, at: 8)
    _u9 = _accessor.readBuffer(of: UInt8.self, at: 9)
    _u10 = _accessor.readBuffer(of: UInt8.self, at: 10)
    _u11 = _accessor.readBuffer(of: UInt8.self, at: 11)
    _u12 = _accessor.readBuffer(of: UInt8.self, at: 12)
    _u13 = _accessor.readBuffer(of: UInt8.self, at: 13)
    _u14 = _accessor.readBuffer(of: UInt8.self, at: 14)
    _u15 = _accessor.readBuffer(of: UInt8.self, at: 15)
  }

  public init(u0: UInt8, u1: UInt8, u2: UInt8, u3: UInt8, u4: UInt8, u5: UInt8, u6: UInt8, u7: UInt8, u8: UInt8, u9: UInt8, u10: UInt8, u11: UInt8, u12: UInt8, u13: UInt8, u14: UInt8, u15: UInt8) {
    _u0 = u0
    _u1 = u1
    _u2 = u2
    _u3 = u3
    _u4 = u4
    _u5 = u5
    _u6 = u6
    _u7 = u7
    _u8 = u8
    _u9 = u9
    _u10 = u10
    _u11 = u11
    _u12 = u12
    _u13 = u13
    _u14 = u14
    _u15 = u15
  }

  public init() {
    _u0 = 0
    _u1 = 0
    _u2 = 0
    _u3 = 0
    _u4 = 0
    _u5 = 0
    _u6 = 0
    _u7 = 0
    _u8 = 0
    _u9 = 0
    _u10 = 0
    _u11 = 0
    _u12 = 0
    _u13 = 0
    _u14 = 0
    _u15 = 0
  }

  public var u0: UInt8 { _u0 }
  public var u1: UInt8 { _u1 }
  public var u2: UInt8 { _u2 }
  public var u3: UInt8 { _u3 }
  public var u4: UInt8 { _u4 }
  public var u5: UInt8 { _u5 }
  public var u6: UInt8 { _u6 }
  public var u7: UInt8 { _u7 }
  public var u8: UInt8 { _u8 }
  public var u9: UInt8 { _u9 }
  public var u10: UInt8 { _u10 }
  public var u11: UInt8 { _u11 }
  public var u12: UInt8 { _u12 }
  public var u13: UInt8 { _u13 }
  public var u14: UInt8 { _u14 }
  public var u15: UInt8 { _u15 }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: FB_UUID.self)
  }
}

public struct FB_UUID_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var u0: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 0) }
  public var u1: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 1) }
  public var u2: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 2) }
  public var u3: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 3) }
  public var u4: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 4) }
  public var u5: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 5) }
  public var u6: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 6) }
  public var u7: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 7) }
  public var u8: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 8) }
  public var u9: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 9) }
  public var u10: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 10) }
  public var u11: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 11) }
  public var u12: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 12) }
  public var u13: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 13) }
  public var u14: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 14) }
  public var u15: UInt8 { return _accessor.readBuffer(of: UInt8.self, at: 15) }
}

public struct FB_Date: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }

  private var _timestampNs: Int64

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _timestampNs = _accessor.readBuffer(of: Int64.self, at: 0)
  }

  public init(timestampNs: Int64) {
    _timestampNs = timestampNs
  }

  public init() {
    _timestampNs = 0
  }

  public var timestampNs: Int64 { _timestampNs }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: FB_Date.self)
  }
}

public struct FB_Date_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var timestampNs: Int64 { return _accessor.readBuffer(of: Int64.self, at: 0) }
}

public struct FB_Vector2: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }

  private var _x: Float32
  private var _y: Float32

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _x = _accessor.readBuffer(of: Float32.self, at: 0)
    _y = _accessor.readBuffer(of: Float32.self, at: 4)
  }

  public init(x: Float32, y: Float32) {
    _x = x
    _y = y
  }

  public init() {
    _x = 0.0
    _y = 0.0
  }

  public var x: Float32 { _x }
  public var y: Float32 { _y }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: FB_Vector2.self)
  }
}

public struct FB_Vector2_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
  public var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
}

public struct FB_PathNode: NativeStruct, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }

  private var _position: FB_Vector2
  private var _cubicIn: FB_Vector2
  private var _cubicOut: FB_Vector2

  public init(_ bb: ByteBuffer, o: Int32) {
    let _accessor = Struct(bb: bb, position: o)
    _position = FB_Vector2(_accessor.bb, o: _accessor.postion + 0)
    _cubicIn = FB_Vector2(_accessor.bb, o: _accessor.postion + 8)
    _cubicOut = FB_Vector2(_accessor.bb, o: _accessor.postion + 16)
  }

  public init(position: FB_Vector2, cubicIn: FB_Vector2, cubicOut: FB_Vector2) {
    _position = position
    _cubicIn = cubicIn
    _cubicOut = cubicOut
  }

  public init() {
    _position = FB_Vector2()
    _cubicIn = FB_Vector2()
    _cubicOut = FB_Vector2()
  }

  public var position: FB_Vector2 { _position }
  public var cubicIn: FB_Vector2 { _cubicIn }
  public var cubicOut: FB_Vector2 { _cubicOut }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: FB_PathNode.self)
  }
}

public struct FB_PathNode_Mutable: FlatBufferObject {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var position: FB_Vector2_Mutable { return FB_Vector2_Mutable(_accessor.bb, o: _accessor.postion + 0) }
  public var cubicIn: FB_Vector2_Mutable { return FB_Vector2_Mutable(_accessor.bb, o: _accessor.postion + 8) }
  public var cubicOut: FB_Vector2_Mutable { return FB_Vector2_Mutable(_accessor.bb, o: _accessor.postion + 16) }
}

public struct FB_Path: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case nodeIds = 4
    case nodes = 6
    case isClosed = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasNodeIds: Bool { let o = _accessor.offset(VTOFFSET.nodeIds.v); return o == 0 ? false : true }
  public var nodeIdsCount: Int32 { let o = _accessor.offset(VTOFFSET.nodeIds.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func nodeIds(at index: Int32) -> FB_UUID? { let o = _accessor.offset(VTOFFSET.nodeIds.v); return o == 0 ? nil : _accessor.directRead(of: FB_UUID.self, offset: _accessor.vector(at: o) + index * 16) }
  public func mutableNodeIds(at index: Int32) -> FB_UUID_Mutable? { let o = _accessor.offset(VTOFFSET.nodeIds.v); return o == 0 ? nil : FB_UUID_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 16) }
  public var hasNodes: Bool { let o = _accessor.offset(VTOFFSET.nodes.v); return o == 0 ? false : true }
  public var nodesCount: Int32 { let o = _accessor.offset(VTOFFSET.nodes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func nodes(at index: Int32) -> FB_PathNode? { let o = _accessor.offset(VTOFFSET.nodes.v); return o == 0 ? nil : _accessor.directRead(of: FB_PathNode.self, offset: _accessor.vector(at: o) + index * 24) }
  public func mutableNodes(at index: Int32) -> FB_PathNode_Mutable? { let o = _accessor.offset(VTOFFSET.nodes.v); return o == 0 ? nil : FB_PathNode_Mutable(_accessor.bb, o: _accessor.vector(at: o) + index * 24) }
  public var isClosed: Bool { let o = _accessor.offset(VTOFFSET.isClosed.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startPath(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(nodeIds: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: nodeIds, at: VTOFFSET.nodeIds.p) }
  public static func startVectorOfNodeIds(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<FB_UUID>.size, elementSize: MemoryLayout<FB_UUID>.alignment)
  }
  public static func addVectorOf(nodes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: nodes, at: VTOFFSET.nodes.p) }
  public static func startVectorOfNodes(_ size: Int, in builder: inout FlatBufferBuilder) {
    builder.startVector(size * MemoryLayout<FB_PathNode>.size, elementSize: MemoryLayout<FB_PathNode>.alignment)
  }
  public static func add(isClosed: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isClosed, def: false,
   at: VTOFFSET.isClosed.p) }
  public static func endPath(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
  public static func createPath(
    _ fbb: inout FlatBufferBuilder,
    nodeIdsVectorOffset nodeIds: Offset,
    nodesVectorOffset nodes: Offset,
    isClosed: Bool = false
  ) -> Offset {
    let __start = FB_Path.startPath(&fbb)
    FB_Path.addVectorOf(nodeIds: nodeIds, &fbb)
    FB_Path.addVectorOf(nodes: nodes, &fbb)
    FB_Path.add(isClosed: isClosed, &fbb)
    return FB_Path.endPath(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.nodeIds.p, fieldName: "nodeIds", required: true, type: ForwardOffset<Vector<FB_UUID, FB_UUID>>.self)
    try _v.visit(field: VTOFFSET.nodes.p, fieldName: "nodes", required: true, type: ForwardOffset<Vector<FB_PathNode, FB_PathNode>>.self)
    try _v.visit(field: VTOFFSET.isClosed.p, fieldName: "isClosed", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct FB_PathEvent_Update_Move: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case offset = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var offset: FB_Vector2! { let o = _accessor.offset(VTOFFSET.offset.v); return _accessor.readBuffer(of: FB_Vector2.self, at: o) }
  public var mutableOffset: FB_Vector2_Mutable! { let o = _accessor.offset(VTOFFSET.offset.v); return FB_Vector2_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public static func startMove(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(offset: FB_Vector2?, _ fbb: inout FlatBufferBuilder) { guard let offset = offset else { return }; fbb.create(struct: offset, position: VTOFFSET.offset.p) }
  public static func endMove(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createMove(
    _ fbb: inout FlatBufferBuilder,
    offset: FB_Vector2
  ) -> Offset {
    let __start = FB_PathEvent_Update_Move.startMove(&fbb)
    FB_PathEvent_Update_Move.add(offset: offset, &fbb)
    return FB_PathEvent_Update_Move.endMove(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.offset.p, fieldName: "offset", required: true, type: FB_Vector2.self)
    _v.finish()
  }
}

public struct FB_PathEvent_Update_NodeCreate: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case prevNodeId = 4
    case nodeId = 6
    case node = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var prevNodeId: FB_UUID? { let o = _accessor.offset(VTOFFSET.prevNodeId.v); return o == 0 ? nil : _accessor.readBuffer(of: FB_UUID.self, at: o) }
  public var mutablePrevNodeId: FB_UUID_Mutable? { let o = _accessor.offset(VTOFFSET.prevNodeId.v); return o == 0 ? nil : FB_UUID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var nodeId: FB_UUID! { let o = _accessor.offset(VTOFFSET.nodeId.v); return _accessor.readBuffer(of: FB_UUID.self, at: o) }
  public var mutableNodeId: FB_UUID_Mutable! { let o = _accessor.offset(VTOFFSET.nodeId.v); return FB_UUID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var node: FB_PathNode! { let o = _accessor.offset(VTOFFSET.node.v); return _accessor.readBuffer(of: FB_PathNode.self, at: o) }
  public var mutableNode: FB_PathNode_Mutable! { let o = _accessor.offset(VTOFFSET.node.v); return FB_PathNode_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public static func startNodeCreate(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(prevNodeId: FB_UUID?, _ fbb: inout FlatBufferBuilder) { guard let prevNodeId = prevNodeId else { return }; fbb.create(struct: prevNodeId, position: VTOFFSET.prevNodeId.p) }
  public static func add(nodeId: FB_UUID?, _ fbb: inout FlatBufferBuilder) { guard let nodeId = nodeId else { return }; fbb.create(struct: nodeId, position: VTOFFSET.nodeId.p) }
  public static func add(node: FB_PathNode?, _ fbb: inout FlatBufferBuilder) { guard let node = node else { return }; fbb.create(struct: node, position: VTOFFSET.node.p) }
  public static func endNodeCreate(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6, 8]); return end }
  public static func createNodeCreate(
    _ fbb: inout FlatBufferBuilder,
    prevNodeId: FB_UUID? = nil,
    nodeId: FB_UUID,
    node: FB_PathNode
  ) -> Offset {
    let __start = FB_PathEvent_Update_NodeCreate.startNodeCreate(&fbb)
    FB_PathEvent_Update_NodeCreate.add(prevNodeId: prevNodeId, &fbb)
    FB_PathEvent_Update_NodeCreate.add(nodeId: nodeId, &fbb)
    FB_PathEvent_Update_NodeCreate.add(node: node, &fbb)
    return FB_PathEvent_Update_NodeCreate.endNodeCreate(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.prevNodeId.p, fieldName: "prevNodeId", required: false, type: FB_UUID.self)
    try _v.visit(field: VTOFFSET.nodeId.p, fieldName: "nodeId", required: true, type: FB_UUID.self)
    try _v.visit(field: VTOFFSET.node.p, fieldName: "node", required: true, type: FB_PathNode.self)
    _v.finish()
  }
}

public struct FB_PathEvent_Update_NodeDelete: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case nodeId = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var nodeId: FB_UUID! { let o = _accessor.offset(VTOFFSET.nodeId.v); return _accessor.readBuffer(of: FB_UUID.self, at: o) }
  public var mutableNodeId: FB_UUID_Mutable! { let o = _accessor.offset(VTOFFSET.nodeId.v); return FB_UUID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public static func startNodeDelete(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(nodeId: FB_UUID?, _ fbb: inout FlatBufferBuilder) { guard let nodeId = nodeId else { return }; fbb.create(struct: nodeId, position: VTOFFSET.nodeId.p) }
  public static func endNodeDelete(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createNodeDelete(
    _ fbb: inout FlatBufferBuilder,
    nodeId: FB_UUID
  ) -> Offset {
    let __start = FB_PathEvent_Update_NodeDelete.startNodeDelete(&fbb)
    FB_PathEvent_Update_NodeDelete.add(nodeId: nodeId, &fbb)
    return FB_PathEvent_Update_NodeDelete.endNodeDelete(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.nodeId.p, fieldName: "nodeId", required: true, type: FB_UUID.self)
    _v.finish()
  }
}

public struct FB_PathEvent_Update_NodeUpdate: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case nodeId = 4
    case node = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var nodeId: FB_UUID! { let o = _accessor.offset(VTOFFSET.nodeId.v); return _accessor.readBuffer(of: FB_UUID.self, at: o) }
  public var mutableNodeId: FB_UUID_Mutable! { let o = _accessor.offset(VTOFFSET.nodeId.v); return FB_UUID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var node: FB_PathNode! { let o = _accessor.offset(VTOFFSET.node.v); return _accessor.readBuffer(of: FB_PathNode.self, at: o) }
  public var mutableNode: FB_PathNode_Mutable! { let o = _accessor.offset(VTOFFSET.node.v); return FB_PathNode_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public static func startNodeUpdate(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(nodeId: FB_UUID?, _ fbb: inout FlatBufferBuilder) { guard let nodeId = nodeId else { return }; fbb.create(struct: nodeId, position: VTOFFSET.nodeId.p) }
  public static func add(node: FB_PathNode?, _ fbb: inout FlatBufferBuilder) { guard let node = node else { return }; fbb.create(struct: node, position: VTOFFSET.node.p) }
  public static func endNodeUpdate(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
  public static func createNodeUpdate(
    _ fbb: inout FlatBufferBuilder,
    nodeId: FB_UUID,
    node: FB_PathNode
  ) -> Offset {
    let __start = FB_PathEvent_Update_NodeUpdate.startNodeUpdate(&fbb)
    FB_PathEvent_Update_NodeUpdate.add(nodeId: nodeId, &fbb)
    FB_PathEvent_Update_NodeUpdate.add(node: node, &fbb)
    return FB_PathEvent_Update_NodeUpdate.endNodeUpdate(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.nodeId.p, fieldName: "nodeId", required: true, type: FB_UUID.self)
    try _v.visit(field: VTOFFSET.node.p, fieldName: "node", required: true, type: FB_PathNode.self)
    _v.finish()
  }
}

public struct FB_PathEvent_Create: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case pathId = 4
    case path = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var pathId: FB_UUID! { let o = _accessor.offset(VTOFFSET.pathId.v); return _accessor.readBuffer(of: FB_UUID.self, at: o) }
  public var mutablePathId: FB_UUID_Mutable! { let o = _accessor.offset(VTOFFSET.pathId.v); return FB_UUID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var path: FB_Path! { let o = _accessor.offset(VTOFFSET.path.v); return FB_Path(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startCreate(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(pathId: FB_UUID?, _ fbb: inout FlatBufferBuilder) { guard let pathId = pathId else { return }; fbb.create(struct: pathId, position: VTOFFSET.pathId.p) }
  public static func add(path: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: path, at: VTOFFSET.path.p) }
  public static func endCreate(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
  public static func createCreate(
    _ fbb: inout FlatBufferBuilder,
    pathId: FB_UUID,
    pathOffset path: Offset
  ) -> Offset {
    let __start = FB_PathEvent_Create.startCreate(&fbb)
    FB_PathEvent_Create.add(pathId: pathId, &fbb)
    FB_PathEvent_Create.add(path: path, &fbb)
    return FB_PathEvent_Create.endCreate(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.pathId.p, fieldName: "pathId", required: true, type: FB_UUID.self)
    try _v.visit(field: VTOFFSET.path.p, fieldName: "path", required: true, type: ForwardOffset<FB_Path>.self)
    _v.finish()
  }
}

public struct FB_PathEvent_Delete: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case pathId = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var pathId: FB_UUID! { let o = _accessor.offset(VTOFFSET.pathId.v); return _accessor.readBuffer(of: FB_UUID.self, at: o) }
  public var mutablePathId: FB_UUID_Mutable! { let o = _accessor.offset(VTOFFSET.pathId.v); return FB_UUID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public static func startDelete(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(pathId: FB_UUID?, _ fbb: inout FlatBufferBuilder) { guard let pathId = pathId else { return }; fbb.create(struct: pathId, position: VTOFFSET.pathId.p) }
  public static func endDelete(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createDelete(
    _ fbb: inout FlatBufferBuilder,
    pathId: FB_UUID
  ) -> Offset {
    let __start = FB_PathEvent_Delete.startDelete(&fbb)
    FB_PathEvent_Delete.add(pathId: pathId, &fbb)
    return FB_PathEvent_Delete.endDelete(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.pathId.p, fieldName: "pathId", required: true, type: FB_UUID.self)
    _v.finish()
  }
}

public struct FB_PathEvent_Update: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case pathId = 4
    case kindsType = 6
    case kinds = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var pathId: FB_UUID! { let o = _accessor.offset(VTOFFSET.pathId.v); return _accessor.readBuffer(of: FB_UUID.self, at: o) }
  public var mutablePathId: FB_UUID_Mutable! { let o = _accessor.offset(VTOFFSET.pathId.v); return FB_UUID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var hasKindsType: Bool { let o = _accessor.offset(VTOFFSET.kindsType.v); return o == 0 ? false : true }
  public var kindsTypeCount: Int32 { let o = _accessor.offset(VTOFFSET.kindsType.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func kindsType(at index: Int32) -> FB_PathEvent_Update_Kind? { let o = _accessor.offset(VTOFFSET.kindsType.v); return o == 0 ? FB_PathEvent_Update_Kind.none_ : FB_PathEvent_Update_Kind(rawValue: _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1)) }
  public var hasKinds: Bool { let o = _accessor.offset(VTOFFSET.kinds.v); return o == 0 ? false : true }
  public var kindsCount: Int32 { let o = _accessor.offset(VTOFFSET.kinds.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func kinds<T: FlatbuffersInitializable>(at index: Int32, type: T.Type) -> T? { let o = _accessor.offset(VTOFFSET.kinds.v); return o == 0 ? nil : _accessor.directUnion(_accessor.vector(at: o) + index * 4) }
  public static func startUpdate(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(pathId: FB_UUID?, _ fbb: inout FlatBufferBuilder) { guard let pathId = pathId else { return }; fbb.create(struct: pathId, position: VTOFFSET.pathId.p) }
  public static func addVectorOf(kindsType: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: kindsType, at: VTOFFSET.kindsType.p) }
  public static func addVectorOf(kinds: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: kinds, at: VTOFFSET.kinds.p) }
  public static func endUpdate(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 8]); return end }
  public static func createUpdate(
    _ fbb: inout FlatBufferBuilder,
    pathId: FB_UUID,
    kindsTypeVectorOffset kindsType: Offset,
    kindsVectorOffset kinds: Offset
  ) -> Offset {
    let __start = FB_PathEvent_Update.startUpdate(&fbb)
    FB_PathEvent_Update.add(pathId: pathId, &fbb)
    FB_PathEvent_Update.addVectorOf(kindsType: kindsType, &fbb)
    FB_PathEvent_Update.addVectorOf(kinds: kinds, &fbb)
    return FB_PathEvent_Update.endUpdate(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.pathId.p, fieldName: "pathId", required: true, type: FB_UUID.self)
    try _v.visitUnionVector(unionKey: VTOFFSET.kindsType.p, unionField: VTOFFSET.kinds.p, unionKeyName: "kindsType", fieldName: "kinds", required: true, completion: { (verifier, key: FB_PathEvent_Update_Kind, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .move:
        try ForwardOffset<FB_PathEvent_Update_Move>.verify(&verifier, at: pos, of: FB_PathEvent_Update_Move.self)
      case .nodecreate:
        try ForwardOffset<FB_PathEvent_Update_NodeCreate>.verify(&verifier, at: pos, of: FB_PathEvent_Update_NodeCreate.self)
      case .nodedelete:
        try ForwardOffset<FB_PathEvent_Update_NodeDelete>.verify(&verifier, at: pos, of: FB_PathEvent_Update_NodeDelete.self)
      case .nodeupdate:
        try ForwardOffset<FB_PathEvent_Update_NodeUpdate>.verify(&verifier, at: pos, of: FB_PathEvent_Update_NodeUpdate.self)
      }
    })
    _v.finish()
  }
}

public struct FB_PathEvent: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case kindType = 4
    case kind = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var kindType: FB_PathEvent_Kind { let o = _accessor.offset(VTOFFSET.kindType.v); return o == 0 ? .none_ : FB_PathEvent_Kind(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func kind<T: FlatbuffersInitializable>(type: T.Type) -> T! { let o = _accessor.offset(VTOFFSET.kind.v); return _accessor.union(o) }
  public static func startPathEvent(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(kindType: FB_PathEvent_Kind, _ fbb: inout FlatBufferBuilder) { fbb.add(element: kindType.rawValue, def: 0, at: VTOFFSET.kindType.p) }
  public static func add(kind: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: kind, at: VTOFFSET.kind.p) }
  public static func endPathEvent(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6]); return end }
  public static func createPathEvent(
    _ fbb: inout FlatBufferBuilder,
    kindType: FB_PathEvent_Kind = .none_,
    kindOffset kind: Offset
  ) -> Offset {
    let __start = FB_PathEvent.startPathEvent(&fbb)
    FB_PathEvent.add(kindType: kindType, &fbb)
    FB_PathEvent.add(kind: kind, &fbb)
    return FB_PathEvent.endPathEvent(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(unionKey: VTOFFSET.kindType.p, unionField: VTOFFSET.kind.p, unionKeyName: "kindType", fieldName: "kind", required: true, completion: { (verifier, key: FB_PathEvent_Kind, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .create:
        try ForwardOffset<FB_PathEvent_Create>.verify(&verifier, at: pos, of: FB_PathEvent_Create.self)
      case .delete:
        try ForwardOffset<FB_PathEvent_Delete>.verify(&verifier, at: pos, of: FB_PathEvent_Delete.self)
      case .update:
        try ForwardOffset<FB_PathEvent_Update>.verify(&verifier, at: pos, of: FB_PathEvent_Update.self)
      }
    })
    _v.finish()
  }
}

public struct FB_DocumentEvent: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_24_3_25() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case time = 6
    case kindType = 8
    case kind = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: FB_UUID! { let o = _accessor.offset(VTOFFSET.id.v); return _accessor.readBuffer(of: FB_UUID.self, at: o) }
  public var mutableId: FB_UUID_Mutable! { let o = _accessor.offset(VTOFFSET.id.v); return FB_UUID_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var time: FB_Date! { let o = _accessor.offset(VTOFFSET.time.v); return _accessor.readBuffer(of: FB_Date.self, at: o) }
  public var mutableTime: FB_Date_Mutable! { let o = _accessor.offset(VTOFFSET.time.v); return FB_Date_Mutable(_accessor.bb, o: o + _accessor.postion) }
  public var kindType: FB_DocumentEvent_Kind { let o = _accessor.offset(VTOFFSET.kindType.v); return o == 0 ? .none_ : FB_DocumentEvent_Kind(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func kind<T: FlatbuffersInitializable>(type: T.Type) -> T! { let o = _accessor.offset(VTOFFSET.kind.v); return _accessor.union(o) }
  public static func startDocumentEvent(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(id: FB_UUID?, _ fbb: inout FlatBufferBuilder) { guard let id = id else { return }; fbb.create(struct: id, position: VTOFFSET.id.p) }
  public static func add(time: FB_Date?, _ fbb: inout FlatBufferBuilder) { guard let time = time else { return }; fbb.create(struct: time, position: VTOFFSET.time.p) }
  public static func add(kindType: FB_DocumentEvent_Kind, _ fbb: inout FlatBufferBuilder) { fbb.add(element: kindType.rawValue, def: 0, at: VTOFFSET.kindType.p) }
  public static func add(kind: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: kind, at: VTOFFSET.kind.p) }
  public static func endDocumentEvent(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6, 10]); return end }
  public static func createDocumentEvent(
    _ fbb: inout FlatBufferBuilder,
    id: FB_UUID,
    time: FB_Date,
    kindType: FB_DocumentEvent_Kind = .none_,
    kindOffset kind: Offset
  ) -> Offset {
    let __start = FB_DocumentEvent.startDocumentEvent(&fbb)
    FB_DocumentEvent.add(id: id, &fbb)
    FB_DocumentEvent.add(time: time, &fbb)
    FB_DocumentEvent.add(kindType: kindType, &fbb)
    FB_DocumentEvent.add(kind: kind, &fbb)
    return FB_DocumentEvent.endDocumentEvent(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: true, type: FB_UUID.self)
    try _v.visit(field: VTOFFSET.time.p, fieldName: "time", required: true, type: FB_Date.self)
    try _v.visit(unionKey: VTOFFSET.kindType.p, unionField: VTOFFSET.kind.p, unionKeyName: "kindType", fieldName: "kind", required: true, completion: { (verifier, key: FB_DocumentEvent_Kind, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .fbPathevent:
        try ForwardOffset<FB_PathEvent>.verify(&verifier, at: pos, of: FB_PathEvent.self)
      }
    })
    _v.finish()
  }
}

