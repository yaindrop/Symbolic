// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: symbolic.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

enum Symbolic_Pb_PathNodeType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case corner // = 0
    case locked // = 1
    case mirrored // = 2
    case UNRECOGNIZED(Int)

    init() {
        self = .corner
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .corner
        case 1: self = .locked
        case 2: self = .mirrored
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .corner: return 0
        case .locked: return 1
        case .mirrored: return 2
        case let .UNRECOGNIZED(i): return i
        }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Symbolic_Pb_PathNodeType] = [
        .corner,
        .locked,
        .mirrored,
    ]
}

enum Symbolic_Pb_PathSegmentType: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case cubic // = 0
    case quadratic // = 1
    case UNRECOGNIZED(Int)

    init() {
        self = .cubic
    }

    init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .cubic
        case 1: self = .quadratic
        default: self = .UNRECOGNIZED(rawValue)
        }
    }

    var rawValue: Int {
        switch self {
        case .cubic: return 0
        case .quadratic: return 1
        case let .UNRECOGNIZED(i): return i
        }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Symbolic_Pb_PathSegmentType] = [
        .cubic,
        .quadratic,
    ]
}

/// A UUID, encoded in accordance with section 4.1.2 of RFC 4122.
struct Symbolic_Pb_UUID: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The higher 64 bits of the UUID, big-endian:
    /// time_low (32) | time_mid (16) | time_hi_and_version (16)
    var hi: UInt64 = 0

    /// The lower 64 bits of the UUID, big-endian:
    /// clock_seq_hi_and_reserved (8) | clock_seq_low (8) | node (48)
    var lo: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Symbolic_Pb_Vector2: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var x: Double = 0

    var y: Double = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Symbolic_Pb_PathNode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var position: Symbolic_Pb_Vector2 {
        get { _position ?? Symbolic_Pb_Vector2() }
        set { _position = newValue }
    }

    /// Returns true if `position` has been explicitly set.
    var hasPosition: Bool { _position != nil }
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    mutating func clearPosition() { _position = nil }

    var cubicIn: Symbolic_Pb_Vector2 {
        get { _cubicIn ?? Symbolic_Pb_Vector2() }
        set { _cubicIn = newValue }
    }

    /// Returns true if `cubicIn` has been explicitly set.
    var hasCubicIn: Bool { _cubicIn != nil }
    /// Clears the value of `cubicIn`. Subsequent reads from it will return its default value.
    mutating func clearCubicIn() { _cubicIn = nil }

    var cubicOut: Symbolic_Pb_Vector2 {
        get { _cubicOut ?? Symbolic_Pb_Vector2() }
        set { _cubicOut = newValue }
    }

    /// Returns true if `cubicOut` has been explicitly set.
    var hasCubicOut: Bool { _cubicOut != nil }
    /// Clears the value of `cubicOut`. Subsequent reads from it will return its default value.
    mutating func clearCubicOut() { _cubicOut = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _position: Symbolic_Pb_Vector2? = nil
    fileprivate var _cubicIn: Symbolic_Pb_Vector2? = nil
    fileprivate var _cubicOut: Symbolic_Pb_Vector2? = nil
}

struct Symbolic_Pb_Path: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodeIds: [Symbolic_Pb_UUID] = []

    var nodes: [Symbolic_Pb_PathNode] = []

    var isClosed: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct Symbolic_Pb_ItemEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Symbolic_Pb_ItemEvent.OneOf_Kind? = nil

    var setMembers: Symbolic_Pb_ItemEvent.SetMembers {
        get {
            if case let .setMembers(v)? = kind { return v }
            return Symbolic_Pb_ItemEvent.SetMembers()
        }
        set { kind = .setMembers(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
        case setMembers(Symbolic_Pb_ItemEvent.SetMembers)
    }

    struct SetMembers: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// null group_id means root
        var groupID: Symbolic_Pb_UUID {
            get { _groupID ?? Symbolic_Pb_UUID() }
            set { _groupID = newValue }
        }

        /// Returns true if `groupID` has been explicitly set.
        var hasGroupID: Bool { _groupID != nil }
        /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
        mutating func clearGroupID() { _groupID = nil }

        var members: [Symbolic_Pb_UUID] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _groupID: Symbolic_Pb_UUID? = nil
    }

    init() {}
}

struct Symbolic_Pb_PathEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Symbolic_Pb_PathEvent.OneOf_Kind? = nil

    var create: Symbolic_Pb_PathEvent.Create {
        get {
            if case let .create(v)? = kind { return v }
            return Symbolic_Pb_PathEvent.Create()
        }
        set { kind = .create(newValue) }
    }

    var delete: Symbolic_Pb_PathEvent.Delete {
        get {
            if case let .delete(v)? = kind { return v }
            return Symbolic_Pb_PathEvent.Delete()
        }
        set { kind = .delete(newValue) }
    }

    var update: Symbolic_Pb_PathEvent.Update {
        get {
            if case let .update(v)? = kind { return v }
            return Symbolic_Pb_PathEvent.Update()
        }
        set { kind = .update(newValue) }
    }

    var merge: Symbolic_Pb_PathEvent.Merge {
        get {
            if case let .merge(v)? = kind { return v }
            return Symbolic_Pb_PathEvent.Merge()
        }
        set { kind = .merge(newValue) }
    }

    var split: Symbolic_Pb_PathEvent.Split {
        get {
            if case let .split(v)? = kind { return v }
            return Symbolic_Pb_PathEvent.Split()
        }
        set { kind = .split(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
        case create(Symbolic_Pb_PathEvent.Create)
        case delete(Symbolic_Pb_PathEvent.Delete)
        case update(Symbolic_Pb_PathEvent.Update)
        case merge(Symbolic_Pb_PathEvent.Merge)
        case split(Symbolic_Pb_PathEvent.Split)
    }

    struct Create: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var pathID: Symbolic_Pb_UUID {
            get { _pathID ?? Symbolic_Pb_UUID() }
            set { _pathID = newValue }
        }

        /// Returns true if `pathID` has been explicitly set.
        var hasPathID: Bool { _pathID != nil }
        /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
        mutating func clearPathID() { _pathID = nil }

        var path: Symbolic_Pb_Path {
            get { _path ?? Symbolic_Pb_Path() }
            set { _path = newValue }
        }

        /// Returns true if `path` has been explicitly set.
        var hasPath: Bool { _path != nil }
        /// Clears the value of `path`. Subsequent reads from it will return its default value.
        mutating func clearPath() { _path = nil }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _pathID: Symbolic_Pb_UUID? = nil
        fileprivate var _path: Symbolic_Pb_Path? = nil
    }

    struct Delete: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var pathID: Symbolic_Pb_UUID {
            get { _pathID ?? Symbolic_Pb_UUID() }
            set { _pathID = newValue }
        }

        /// Returns true if `pathID` has been explicitly set.
        var hasPathID: Bool { _pathID != nil }
        /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
        mutating func clearPathID() { _pathID = nil }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _pathID: Symbolic_Pb_UUID? = nil
    }

    struct Update: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var pathID: Symbolic_Pb_UUID {
            get { _pathID ?? Symbolic_Pb_UUID() }
            set { _pathID = newValue }
        }

        /// Returns true if `pathID` has been explicitly set.
        var hasPathID: Bool { _pathID != nil }
        /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
        mutating func clearPathID() { _pathID = nil }

        var kind: Symbolic_Pb_PathEvent.Update.OneOf_Kind? = nil

        var move: Symbolic_Pb_PathEvent.Update.Move {
            get {
                if case let .move(v)? = kind { return v }
                return Symbolic_Pb_PathEvent.Update.Move()
            }
            set { kind = .move(newValue) }
        }

        var nodeCreate: Symbolic_Pb_PathEvent.Update.NodeCreate {
            get {
                if case let .nodeCreate(v)? = kind { return v }
                return Symbolic_Pb_PathEvent.Update.NodeCreate()
            }
            set { kind = .nodeCreate(newValue) }
        }

        var nodeDelete: Symbolic_Pb_PathEvent.Update.NodeDelete {
            get {
                if case let .nodeDelete(v)? = kind { return v }
                return Symbolic_Pb_PathEvent.Update.NodeDelete()
            }
            set { kind = .nodeDelete(newValue) }
        }

        var nodeUpdate: Symbolic_Pb_PathEvent.Update.NodeUpdate {
            get {
                if case let .nodeUpdate(v)? = kind { return v }
                return Symbolic_Pb_PathEvent.Update.NodeUpdate()
            }
            set { kind = .nodeUpdate(newValue) }
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_Kind: Equatable, Sendable {
            case move(Symbolic_Pb_PathEvent.Update.Move)
            case nodeCreate(Symbolic_Pb_PathEvent.Update.NodeCreate)
            case nodeDelete(Symbolic_Pb_PathEvent.Update.NodeDelete)
            case nodeUpdate(Symbolic_Pb_PathEvent.Update.NodeUpdate)
        }

        struct Move: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var offset: Symbolic_Pb_Vector2 {
                get { _offset ?? Symbolic_Pb_Vector2() }
                set { _offset = newValue }
            }

            /// Returns true if `offset` has been explicitly set.
            var hasOffset: Bool { _offset != nil }
            /// Clears the value of `offset`. Subsequent reads from it will return its default value.
            mutating func clearOffset() { _offset = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _offset: Symbolic_Pb_Vector2? = nil
        }

        struct NodeCreate: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var prevNodeID: Symbolic_Pb_UUID {
                get { _prevNodeID ?? Symbolic_Pb_UUID() }
                set { _prevNodeID = newValue }
            }

            /// Returns true if `prevNodeID` has been explicitly set.
            var hasPrevNodeID: Bool { _prevNodeID != nil }
            /// Clears the value of `prevNodeID`. Subsequent reads from it will return its default value.
            mutating func clearPrevNodeID() { _prevNodeID = nil }

            var nodeID: Symbolic_Pb_UUID {
                get { _nodeID ?? Symbolic_Pb_UUID() }
                set { _nodeID = newValue }
            }

            /// Returns true if `nodeID` has been explicitly set.
            var hasNodeID: Bool { _nodeID != nil }
            /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
            mutating func clearNodeID() { _nodeID = nil }

            var node: Symbolic_Pb_PathNode {
                get { _node ?? Symbolic_Pb_PathNode() }
                set { _node = newValue }
            }

            /// Returns true if `node` has been explicitly set.
            var hasNode: Bool { _node != nil }
            /// Clears the value of `node`. Subsequent reads from it will return its default value.
            mutating func clearNode() { _node = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _prevNodeID: Symbolic_Pb_UUID? = nil
            fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
            fileprivate var _node: Symbolic_Pb_PathNode? = nil
        }

        struct NodeDelete: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var nodeID: Symbolic_Pb_UUID {
                get { _nodeID ?? Symbolic_Pb_UUID() }
                set { _nodeID = newValue }
            }

            /// Returns true if `nodeID` has been explicitly set.
            var hasNodeID: Bool { _nodeID != nil }
            /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
            mutating func clearNodeID() { _nodeID = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
        }

        struct NodeUpdate: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var nodeID: Symbolic_Pb_UUID {
                get { _nodeID ?? Symbolic_Pb_UUID() }
                set { _nodeID = newValue }
            }

            /// Returns true if `nodeID` has been explicitly set.
            var hasNodeID: Bool { _nodeID != nil }
            /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
            mutating func clearNodeID() { _nodeID = nil }

            var node: Symbolic_Pb_PathNode {
                get { _node ?? Symbolic_Pb_PathNode() }
                set { _node = newValue }
            }

            /// Returns true if `node` has been explicitly set.
            var hasNode: Bool { _node != nil }
            /// Clears the value of `node`. Subsequent reads from it will return its default value.
            mutating func clearNode() { _node = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
            fileprivate var _node: Symbolic_Pb_PathNode? = nil
        }

        init() {}

        fileprivate var _pathID: Symbolic_Pb_UUID? = nil
    }

    struct Merge: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var pathID: Symbolic_Pb_UUID {
            get { _pathID ?? Symbolic_Pb_UUID() }
            set { _pathID = newValue }
        }

        /// Returns true if `pathID` has been explicitly set.
        var hasPathID: Bool { _pathID != nil }
        /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
        mutating func clearPathID() { _pathID = nil }

        var endingNodeID: Symbolic_Pb_UUID {
            get { _endingNodeID ?? Symbolic_Pb_UUID() }
            set { _endingNodeID = newValue }
        }

        /// Returns true if `endingNodeID` has been explicitly set.
        var hasEndingNodeID: Bool { _endingNodeID != nil }
        /// Clears the value of `endingNodeID`. Subsequent reads from it will return its default value.
        mutating func clearEndingNodeID() { _endingNodeID = nil }

        var mergedPathID: Symbolic_Pb_UUID {
            get { _mergedPathID ?? Symbolic_Pb_UUID() }
            set { _mergedPathID = newValue }
        }

        /// Returns true if `mergedPathID` has been explicitly set.
        var hasMergedPathID: Bool { _mergedPathID != nil }
        /// Clears the value of `mergedPathID`. Subsequent reads from it will return its default value.
        mutating func clearMergedPathID() { _mergedPathID = nil }

        var mergedEndingNodeID: Symbolic_Pb_UUID {
            get { _mergedEndingNodeID ?? Symbolic_Pb_UUID() }
            set { _mergedEndingNodeID = newValue }
        }

        /// Returns true if `mergedEndingNodeID` has been explicitly set.
        var hasMergedEndingNodeID: Bool { _mergedEndingNodeID != nil }
        /// Clears the value of `mergedEndingNodeID`. Subsequent reads from it will return its default value.
        mutating func clearMergedEndingNodeID() { _mergedEndingNodeID = nil }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _pathID: Symbolic_Pb_UUID? = nil
        fileprivate var _endingNodeID: Symbolic_Pb_UUID? = nil
        fileprivate var _mergedPathID: Symbolic_Pb_UUID? = nil
        fileprivate var _mergedEndingNodeID: Symbolic_Pb_UUID? = nil
    }

    struct Split: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var pathID: Symbolic_Pb_UUID {
            get { _pathID ?? Symbolic_Pb_UUID() }
            set { _pathID = newValue }
        }

        /// Returns true if `pathID` has been explicitly set.
        var hasPathID: Bool { _pathID != nil }
        /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
        mutating func clearPathID() { _pathID = nil }

        var nodeID: Symbolic_Pb_UUID {
            get { _nodeID ?? Symbolic_Pb_UUID() }
            set { _nodeID = newValue }
        }

        /// Returns true if `nodeID` has been explicitly set.
        var hasNodeID: Bool { _nodeID != nil }
        /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
        mutating func clearNodeID() { _nodeID = nil }

        var newPathID: Symbolic_Pb_UUID {
            get { _newPathID ?? Symbolic_Pb_UUID() }
            set { _newPathID = newValue }
        }

        /// Returns true if `newPathID` has been explicitly set.
        var hasNewPathID: Bool { _newPathID != nil }
        /// Clears the value of `newPathID`. Subsequent reads from it will return its default value.
        mutating func clearNewPathID() { _newPathID = nil }

        var newNodeID: Symbolic_Pb_UUID {
            get { _newNodeID ?? Symbolic_Pb_UUID() }
            set { _newNodeID = newValue }
        }

        /// Returns true if `newNodeID` has been explicitly set.
        var hasNewNodeID: Bool { _newNodeID != nil }
        /// Clears the value of `newNodeID`. Subsequent reads from it will return its default value.
        mutating func clearNewNodeID() { _newNodeID = nil }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _pathID: Symbolic_Pb_UUID? = nil
        fileprivate var _nodeID: Symbolic_Pb_UUID? = nil
        fileprivate var _newPathID: Symbolic_Pb_UUID? = nil
        fileprivate var _newNodeID: Symbolic_Pb_UUID? = nil
    }

    init() {}
}

struct Symbolic_Pb_PathPropertyEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: Symbolic_Pb_PathPropertyEvent.OneOf_Kind? = nil

    var update: Symbolic_Pb_PathPropertyEvent.Update {
        get {
            if case let .update(v)? = kind { return v }
            return Symbolic_Pb_PathPropertyEvent.Update()
        }
        set { kind = .update(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
        case update(Symbolic_Pb_PathPropertyEvent.Update)
    }

    struct Update: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var pathID: Symbolic_Pb_UUID {
            get { _pathID ?? Symbolic_Pb_UUID() }
            set { _pathID = newValue }
        }

        /// Returns true if `pathID` has been explicitly set.
        var hasPathID: Bool { _pathID != nil }
        /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
        mutating func clearPathID() { _pathID = nil }

        var kind: Symbolic_Pb_PathPropertyEvent.Update.OneOf_Kind? = nil

        var setName: Symbolic_Pb_PathPropertyEvent.Update.SetName {
            get {
                if case let .setName(v)? = kind { return v }
                return Symbolic_Pb_PathPropertyEvent.Update.SetName()
            }
            set { kind = .setName(newValue) }
        }

        var setNodeType: Symbolic_Pb_PathPropertyEvent.Update.SetNodeType {
            get {
                if case let .setNodeType(v)? = kind { return v }
                return Symbolic_Pb_PathPropertyEvent.Update.SetNodeType()
            }
            set { kind = .setNodeType(newValue) }
        }

        var setSegmentType: Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType {
            get {
                if case let .setSegmentType(v)? = kind { return v }
                return Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType()
            }
            set { kind = .setSegmentType(newValue) }
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_Kind: Equatable, Sendable {
            case setName(Symbolic_Pb_PathPropertyEvent.Update.SetName)
            case setNodeType(Symbolic_Pb_PathPropertyEvent.Update.SetNodeType)
            case setSegmentType(Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType)
        }

        struct SetName: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var name: String {
                get { _name ?? String() }
                set { _name = newValue }
            }

            /// Returns true if `name` has been explicitly set.
            var hasName: Bool { _name != nil }
            /// Clears the value of `name`. Subsequent reads from it will return its default value.
            mutating func clearName() { _name = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _name: String? = nil
        }

        struct SetNodeType: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var nodeIds: [Symbolic_Pb_UUID] = []

            var nodeType: Symbolic_Pb_PathNodeType {
                get { _nodeType ?? .corner }
                set { _nodeType = newValue }
            }

            /// Returns true if `nodeType` has been explicitly set.
            var hasNodeType: Bool { _nodeType != nil }
            /// Clears the value of `nodeType`. Subsequent reads from it will return its default value.
            mutating func clearNodeType() { _nodeType = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _nodeType: Symbolic_Pb_PathNodeType? = nil
        }

        struct SetSegmentType: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var fromNodeIds: [Symbolic_Pb_UUID] = []

            var segmentType: Symbolic_Pb_PathSegmentType {
                get { _segmentType ?? .cubic }
                set { _segmentType = newValue }
            }

            /// Returns true if `segmentType` has been explicitly set.
            var hasSegmentType: Bool { _segmentType != nil }
            /// Clears the value of `segmentType`. Subsequent reads from it will return its default value.
            mutating func clearSegmentType() { _segmentType = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _segmentType: Symbolic_Pb_PathSegmentType? = nil
        }

        init() {}

        fileprivate var _pathID: Symbolic_Pb_UUID? = nil
    }

    init() {}
}

struct Symbolic_Pb_DocumentEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: Symbolic_Pb_UUID {
        get { _id ?? Symbolic_Pb_UUID() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    var hasID: Bool { _id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() { _id = nil }

    var time: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _time ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _time = newValue }
    }

    /// Returns true if `time` has been explicitly set.
    var hasTime: Bool { _time != nil }
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    mutating func clearTime() { _time = nil }

    var kind: Symbolic_Pb_DocumentEvent.OneOf_Kind? = nil

    var single: Symbolic_Pb_DocumentEvent.Single {
        get {
            if case let .single(v)? = kind { return v }
            return Symbolic_Pb_DocumentEvent.Single()
        }
        set { kind = .single(newValue) }
    }

    var compound: Symbolic_Pb_DocumentEvent.Compound {
        get {
            if case let .compound(v)? = kind { return v }
            return Symbolic_Pb_DocumentEvent.Compound()
        }
        set { kind = .compound(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
        case single(Symbolic_Pb_DocumentEvent.Single)
        case compound(Symbolic_Pb_DocumentEvent.Compound)
    }

    struct Single: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var kind: Symbolic_Pb_DocumentEvent.Single.OneOf_Kind? = nil

        var itemEvent: Symbolic_Pb_ItemEvent {
            get {
                if case let .itemEvent(v)? = kind { return v }
                return Symbolic_Pb_ItemEvent()
            }
            set { kind = .itemEvent(newValue) }
        }

        var pathEvent: Symbolic_Pb_PathEvent {
            get {
                if case let .pathEvent(v)? = kind { return v }
                return Symbolic_Pb_PathEvent()
            }
            set { kind = .pathEvent(newValue) }
        }

        var pathPropertyEvent: Symbolic_Pb_PathPropertyEvent {
            get {
                if case let .pathPropertyEvent(v)? = kind { return v }
                return Symbolic_Pb_PathPropertyEvent()
            }
            set { kind = .pathPropertyEvent(newValue) }
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_Kind: Equatable, Sendable {
            case itemEvent(Symbolic_Pb_ItemEvent)
            case pathEvent(Symbolic_Pb_PathEvent)
            case pathPropertyEvent(Symbolic_Pb_PathPropertyEvent)
        }

        init() {}
    }

    struct Compound: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var events: [Symbolic_Pb_DocumentEvent.Single] = []

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
    }

    init() {}

    fileprivate var _id: Symbolic_Pb_UUID? = nil
    fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "symbolic.pb"

extension Symbolic_Pb_PathNodeType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "corner"),
        1: .same(proto: "locked"),
        2: .same(proto: "mirrored"),
    ]
}

extension Symbolic_Pb_PathSegmentType: SwiftProtobuf._ProtoNameProviding {
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "cubic"),
        1: .same(proto: "quadratic"),
    ]
}

extension Symbolic_Pb_UUID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UUID"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "hi"),
        2: .same(proto: "lo"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularFixed64Field(value: &hi)
            case 2: try decoder.decodeSingularFixed64Field(value: &lo)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if hi != 0 {
            try visitor.visitSingularFixed64Field(value: hi, fieldNumber: 1)
        }
        if lo != 0 {
            try visitor.visitSingularFixed64Field(value: lo, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_UUID, rhs: Symbolic_Pb_UUID) -> Bool {
        if lhs.hi != rhs.hi { return false }
        if lhs.lo != rhs.lo { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_Vector2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Vector2"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "x"),
        2: .same(proto: "y"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularDoubleField(value: &x)
            case 2: try decoder.decodeSingularDoubleField(value: &y)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if x.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: x, fieldNumber: 1)
        }
        if y.bitPattern != 0 {
            try visitor.visitSingularDoubleField(value: y, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_Vector2, rhs: Symbolic_Pb_Vector2) -> Bool {
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PathNode"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .standard(proto: "cubic_in"),
        3: .standard(proto: "cubic_out"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_position)
            case 2: try decoder.decodeSingularMessageField(value: &_cubicIn)
            case 3: try decoder.decodeSingularMessageField(value: &_cubicOut)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._position {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._cubicIn {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._cubicOut {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathNode, rhs: Symbolic_Pb_PathNode) -> Bool {
        if lhs._position != rhs._position { return false }
        if lhs._cubicIn != rhs._cubicIn { return false }
        if lhs._cubicOut != rhs._cubicOut { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_Path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Path"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "node_ids"),
        2: .same(proto: "nodes"),
        3: .standard(proto: "is_closed"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &nodeIds)
            case 2: try decoder.decodeRepeatedMessageField(value: &nodes)
            case 3: try decoder.decodeSingularBoolField(value: &isClosed)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !nodeIds.isEmpty {
            try visitor.visitRepeatedMessageField(value: nodeIds, fieldNumber: 1)
        }
        if !nodes.isEmpty {
            try visitor.visitRepeatedMessageField(value: nodes, fieldNumber: 2)
        }
        if isClosed != false {
            try visitor.visitSingularBoolField(value: isClosed, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_Path, rhs: Symbolic_Pb_Path) -> Bool {
        if lhs.nodeIds != rhs.nodeIds { return false }
        if lhs.nodes != rhs.nodes { return false }
        if lhs.isClosed != rhs.isClosed { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_ItemEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".ItemEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .standard(proto: "set_members"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try {
                    var v: Symbolic_Pb_ItemEvent.SetMembers?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .setMembers(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .setMembers(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if case let .setMembers(v)? = self.kind {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_ItemEvent, rhs: Symbolic_Pb_ItemEvent) -> Bool {
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_ItemEvent.SetMembers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_ItemEvent.protoMessageName + ".SetMembers"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "group_id"),
        2: .same(proto: "members"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_groupID)
            case 2: try decoder.decodeRepeatedMessageField(value: &members)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._groupID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        if !members.isEmpty {
            try visitor.visitRepeatedMessageField(value: members, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_ItemEvent.SetMembers, rhs: Symbolic_Pb_ItemEvent.SetMembers) -> Bool {
        if lhs._groupID != rhs._groupID { return false }
        if lhs.members != rhs.members { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PathEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .same(proto: "create"),
        102: .same(proto: "delete"),
        103: .same(proto: "update"),
        104: .same(proto: "merge"),
        105: .same(proto: "split"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try {
                    var v: Symbolic_Pb_PathEvent.Create?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .create(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .create(v)
                    }
                }()
            case 102: try {
                    var v: Symbolic_Pb_PathEvent.Delete?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .delete(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .delete(v)
                    }
                }()
            case 103: try {
                    var v: Symbolic_Pb_PathEvent.Update?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .update(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .update(v)
                    }
                }()
            case 104: try {
                    var v: Symbolic_Pb_PathEvent.Merge?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .merge(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .merge(v)
                    }
                }()
            case 105: try {
                    var v: Symbolic_Pb_PathEvent.Split?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .split(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .split(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch kind {
        case .create?: try {
                guard case let .create(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
            }()
        case .delete?: try {
                guard case let .delete(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
            }()
        case .update?: try {
                guard case let .update(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
            }()
        case .merge?: try {
                guard case let .merge(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
            }()
        case .split?: try {
                guard case let .split(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent, rhs: Symbolic_Pb_PathEvent) -> Bool {
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Create"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "path_id"),
        2: .same(proto: "path"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_pathID)
            case 2: try decoder.decodeSingularMessageField(value: &_path)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._pathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._path {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent.Create, rhs: Symbolic_Pb_PathEvent.Create) -> Bool {
        if lhs._pathID != rhs._pathID { return false }
        if lhs._path != rhs._path { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Delete"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "path_id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_pathID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._pathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent.Delete, rhs: Symbolic_Pb_PathEvent.Delete) -> Bool {
        if lhs._pathID != rhs._pathID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Update"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "path_id"),
        101: .same(proto: "move"),
        102: .standard(proto: "node_create"),
        103: .standard(proto: "node_delete"),
        104: .standard(proto: "node_update"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_pathID)
            case 101: try {
                    var v: Symbolic_Pb_PathEvent.Update.Move?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .move(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .move(v)
                    }
                }()
            case 102: try {
                    var v: Symbolic_Pb_PathEvent.Update.NodeCreate?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .nodeCreate(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .nodeCreate(v)
                    }
                }()
            case 103: try {
                    var v: Symbolic_Pb_PathEvent.Update.NodeDelete?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .nodeDelete(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .nodeDelete(v)
                    }
                }()
            case 104: try {
                    var v: Symbolic_Pb_PathEvent.Update.NodeUpdate?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .nodeUpdate(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .nodeUpdate(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._pathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        switch kind {
        case .move?: try {
                guard case let .move(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
            }()
        case .nodeCreate?: try {
                guard case let .nodeCreate(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
            }()
        case .nodeDelete?: try {
                guard case let .nodeDelete(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
            }()
        case .nodeUpdate?: try {
                guard case let .nodeUpdate(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent.Update, rhs: Symbolic_Pb_PathEvent.Update) -> Bool {
        if lhs._pathID != rhs._pathID { return false }
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent.Update.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathEvent.Update.protoMessageName + ".Move"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "offset"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_offset)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._offset {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent.Update.Move, rhs: Symbolic_Pb_PathEvent.Update.Move) -> Bool {
        if lhs._offset != rhs._offset { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent.Update.NodeCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathEvent.Update.protoMessageName + ".NodeCreate"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "prev_node_id"),
        2: .standard(proto: "node_id"),
        3: .same(proto: "node"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_prevNodeID)
            case 2: try decoder.decodeSingularMessageField(value: &_nodeID)
            case 3: try decoder.decodeSingularMessageField(value: &_node)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._prevNodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._nodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._node {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent.Update.NodeCreate, rhs: Symbolic_Pb_PathEvent.Update.NodeCreate) -> Bool {
        if lhs._prevNodeID != rhs._prevNodeID { return false }
        if lhs._nodeID != rhs._nodeID { return false }
        if lhs._node != rhs._node { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent.Update.NodeDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathEvent.Update.protoMessageName + ".NodeDelete"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "node_id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_nodeID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._nodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent.Update.NodeDelete, rhs: Symbolic_Pb_PathEvent.Update.NodeDelete) -> Bool {
        if lhs._nodeID != rhs._nodeID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent.Update.NodeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathEvent.Update.protoMessageName + ".NodeUpdate"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "node_id"),
        2: .same(proto: "node"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_nodeID)
            case 2: try decoder.decodeSingularMessageField(value: &_node)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._nodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._node {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent.Update.NodeUpdate, rhs: Symbolic_Pb_PathEvent.Update.NodeUpdate) -> Bool {
        if lhs._nodeID != rhs._nodeID { return false }
        if lhs._node != rhs._node { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent.Merge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Merge"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "path_id"),
        2: .standard(proto: "ending_node_id"),
        3: .standard(proto: "merged_path_id"),
        4: .standard(proto: "merged_ending_node_id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_pathID)
            case 2: try decoder.decodeSingularMessageField(value: &_endingNodeID)
            case 3: try decoder.decodeSingularMessageField(value: &_mergedPathID)
            case 4: try decoder.decodeSingularMessageField(value: &_mergedEndingNodeID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._pathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._endingNodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._mergedPathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._mergedEndingNodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent.Merge, rhs: Symbolic_Pb_PathEvent.Merge) -> Bool {
        if lhs._pathID != rhs._pathID { return false }
        if lhs._endingNodeID != rhs._endingNodeID { return false }
        if lhs._mergedPathID != rhs._mergedPathID { return false }
        if lhs._mergedEndingNodeID != rhs._mergedEndingNodeID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathEvent.Split: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathEvent.protoMessageName + ".Split"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "path_id"),
        2: .standard(proto: "node_id"),
        3: .standard(proto: "new_path_id"),
        4: .standard(proto: "new_node_id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_pathID)
            case 2: try decoder.decodeSingularMessageField(value: &_nodeID)
            case 3: try decoder.decodeSingularMessageField(value: &_newPathID)
            case 4: try decoder.decodeSingularMessageField(value: &_newNodeID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._pathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._nodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._newPathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try { if let v = self._newNodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathEvent.Split, rhs: Symbolic_Pb_PathEvent.Split) -> Bool {
        if lhs._pathID != rhs._pathID { return false }
        if lhs._nodeID != rhs._nodeID { return false }
        if lhs._newPathID != rhs._newPathID { return false }
        if lhs._newNodeID != rhs._newNodeID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathPropertyEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PathPropertyEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .same(proto: "update"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try {
                    var v: Symbolic_Pb_PathPropertyEvent.Update?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .update(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .update(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if case let .update(v)? = self.kind {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathPropertyEvent, rhs: Symbolic_Pb_PathPropertyEvent) -> Bool {
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathPropertyEvent.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathPropertyEvent.protoMessageName + ".Update"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "path_id"),
        101: .standard(proto: "set_name"),
        102: .standard(proto: "set_node_type"),
        103: .standard(proto: "set_segment_type"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_pathID)
            case 101: try {
                    var v: Symbolic_Pb_PathPropertyEvent.Update.SetName?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .setName(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .setName(v)
                    }
                }()
            case 102: try {
                    var v: Symbolic_Pb_PathPropertyEvent.Update.SetNodeType?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .setNodeType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .setNodeType(v)
                    }
                }()
            case 103: try {
                    var v: Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .setSegmentType(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .setSegmentType(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._pathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        switch kind {
        case .setName?: try {
                guard case let .setName(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
            }()
        case .setNodeType?: try {
                guard case let .setNodeType(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
            }()
        case .setSegmentType?: try {
                guard case let .setSegmentType(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathPropertyEvent.Update, rhs: Symbolic_Pb_PathPropertyEvent.Update) -> Bool {
        if lhs._pathID != rhs._pathID { return false }
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathPropertyEvent.Update.SetName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathPropertyEvent.Update.protoMessageName + ".SetName"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "name"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &_name)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._name {
            try visitor.visitSingularStringField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathPropertyEvent.Update.SetName, rhs: Symbolic_Pb_PathPropertyEvent.Update.SetName) -> Bool {
        if lhs._name != rhs._name { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathPropertyEvent.Update.SetNodeType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathPropertyEvent.Update.protoMessageName + ".SetNodeType"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "node_ids"),
        2: .standard(proto: "node_type"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &nodeIds)
            case 2: try decoder.decodeSingularEnumField(value: &_nodeType)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !nodeIds.isEmpty {
            try visitor.visitRepeatedMessageField(value: nodeIds, fieldNumber: 1)
        }
        try { if let v = self._nodeType {
            try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathPropertyEvent.Update.SetNodeType, rhs: Symbolic_Pb_PathPropertyEvent.Update.SetNodeType) -> Bool {
        if lhs.nodeIds != rhs.nodeIds { return false }
        if lhs._nodeType != rhs._nodeType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_PathPropertyEvent.Update.protoMessageName + ".SetSegmentType"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "from_node_ids"),
        2: .standard(proto: "segment_type"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &fromNodeIds)
            case 2: try decoder.decodeSingularEnumField(value: &_segmentType)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        if !fromNodeIds.isEmpty {
            try visitor.visitRepeatedMessageField(value: fromNodeIds, fieldNumber: 1)
        }
        try { if let v = self._segmentType {
            try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType, rhs: Symbolic_Pb_PathPropertyEvent.Update.SetSegmentType) -> Bool {
        if lhs.fromNodeIds != rhs.fromNodeIds { return false }
        if lhs._segmentType != rhs._segmentType { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_DocumentEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DocumentEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "time"),
        101: .same(proto: "single"),
        102: .same(proto: "compound"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeSingularMessageField(value: &_time)
            case 101: try {
                    var v: Symbolic_Pb_DocumentEvent.Single?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .single(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .single(v)
                    }
                }()
            case 102: try {
                    var v: Symbolic_Pb_DocumentEvent.Compound?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .compound(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .compound(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._time {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        switch kind {
        case .single?: try {
                guard case let .single(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
            }()
        case .compound?: try {
                guard case let .compound(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_DocumentEvent, rhs: Symbolic_Pb_DocumentEvent) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._time != rhs._time { return false }
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_DocumentEvent.Single: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_DocumentEvent.protoMessageName + ".Single"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .standard(proto: "item_event"),
        102: .standard(proto: "path_event"),
        103: .standard(proto: "path_property_event"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try {
                    var v: Symbolic_Pb_ItemEvent?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .itemEvent(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .itemEvent(v)
                    }
                }()
            case 102: try {
                    var v: Symbolic_Pb_PathEvent?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .pathEvent(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .pathEvent(v)
                    }
                }()
            case 103: try {
                    var v: Symbolic_Pb_PathPropertyEvent?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .pathPropertyEvent(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .pathPropertyEvent(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch kind {
        case .itemEvent?: try {
                guard case let .itemEvent(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
            }()
        case .pathEvent?: try {
                guard case let .pathEvent(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
            }()
        case .pathPropertyEvent?: try {
                guard case let .pathPropertyEvent(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_DocumentEvent.Single, rhs: Symbolic_Pb_DocumentEvent.Single) -> Bool {
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension Symbolic_Pb_DocumentEvent.Compound: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = Symbolic_Pb_DocumentEvent.protoMessageName + ".Compound"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "events"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &events)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !events.isEmpty {
            try visitor.visitRepeatedMessageField(value: events, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: Symbolic_Pb_DocumentEvent.Compound, rhs: Symbolic_Pb_DocumentEvent.Compound) -> Bool {
        if lhs.events != rhs.events { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
