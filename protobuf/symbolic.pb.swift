// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: symbolic.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

struct PB_UUID: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 16 bytes / 128 bits long
    var data: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct PB_Vector2: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var x: Float = 0

    var y: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct PB_PathNode: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var position: PB_Vector2 {
        get { _position ?? PB_Vector2() }
        set { _position = newValue }
    }

    /// Returns true if `position` has been explicitly set.
    var hasPosition: Bool { _position != nil }
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    mutating func clearPosition() { _position = nil }

    var cubicIn: PB_Vector2 {
        get { _cubicIn ?? PB_Vector2() }
        set { _cubicIn = newValue }
    }

    /// Returns true if `cubicIn` has been explicitly set.
    var hasCubicIn: Bool { _cubicIn != nil }
    /// Clears the value of `cubicIn`. Subsequent reads from it will return its default value.
    mutating func clearCubicIn() { _cubicIn = nil }

    var cubicOut: PB_Vector2 {
        get { _cubicOut ?? PB_Vector2() }
        set { _cubicOut = newValue }
    }

    /// Returns true if `cubicOut` has been explicitly set.
    var hasCubicOut: Bool { _cubicOut != nil }
    /// Clears the value of `cubicOut`. Subsequent reads from it will return its default value.
    mutating func clearCubicOut() { _cubicOut = nil }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _position: PB_Vector2? = nil
    fileprivate var _cubicIn: PB_Vector2? = nil
    fileprivate var _cubicOut: PB_Vector2? = nil
}

struct PB_Path: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var nodeIds: [PB_UUID] = []

    var nodes: [PB_PathNode] = []

    var isClosed: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
}

struct PB_PathEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var kind: PB_PathEvent.OneOf_Kind? = nil

    var create: PB_PathEvent.Create {
        get {
            if case let .create(v)? = kind { return v }
            return PB_PathEvent.Create()
        }
        set { kind = .create(newValue) }
    }

    var delete: PB_PathEvent.Delete {
        get {
            if case let .delete(v)? = kind { return v }
            return PB_PathEvent.Delete()
        }
        set { kind = .delete(newValue) }
    }

    var update: PB_PathEvent.Update {
        get {
            if case let .update(v)? = kind { return v }
            return PB_PathEvent.Update()
        }
        set { kind = .update(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
        case create(PB_PathEvent.Create)
        case delete(PB_PathEvent.Delete)
        case update(PB_PathEvent.Update)
    }

    struct Create: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var pathID: PB_UUID {
            get { _pathID ?? PB_UUID() }
            set { _pathID = newValue }
        }

        /// Returns true if `pathID` has been explicitly set.
        var hasPathID: Bool { _pathID != nil }
        /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
        mutating func clearPathID() { _pathID = nil }

        var path: PB_Path {
            get { _path ?? PB_Path() }
            set { _path = newValue }
        }

        /// Returns true if `path` has been explicitly set.
        var hasPath: Bool { _path != nil }
        /// Clears the value of `path`. Subsequent reads from it will return its default value.
        mutating func clearPath() { _path = nil }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _pathID: PB_UUID? = nil
        fileprivate var _path: PB_Path? = nil
    }

    struct Delete: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var pathID: PB_UUID {
            get { _pathID ?? PB_UUID() }
            set { _pathID = newValue }
        }

        /// Returns true if `pathID` has been explicitly set.
        var hasPathID: Bool { _pathID != nil }
        /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
        mutating func clearPathID() { _pathID = nil }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _pathID: PB_UUID? = nil
    }

    struct Update: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var pathID: PB_UUID {
            get { _pathID ?? PB_UUID() }
            set { _pathID = newValue }
        }

        /// Returns true if `pathID` has been explicitly set.
        var hasPathID: Bool { _pathID != nil }
        /// Clears the value of `pathID`. Subsequent reads from it will return its default value.
        mutating func clearPathID() { _pathID = nil }

        var kind: PB_PathEvent.Update.OneOf_Kind? = nil

        var move: PB_PathEvent.Update.Move {
            get {
                if case let .move(v)? = kind { return v }
                return PB_PathEvent.Update.Move()
            }
            set { kind = .move(newValue) }
        }

        var nodeCreate: PB_PathEvent.Update.NodeCreate {
            get {
                if case let .nodeCreate(v)? = kind { return v }
                return PB_PathEvent.Update.NodeCreate()
            }
            set { kind = .nodeCreate(newValue) }
        }

        var nodeDelete: PB_PathEvent.Update.NodeDelete {
            get {
                if case let .nodeDelete(v)? = kind { return v }
                return PB_PathEvent.Update.NodeDelete()
            }
            set { kind = .nodeDelete(newValue) }
        }

        var nodeUpdate: PB_PathEvent.Update.NodeUpdate {
            get {
                if case let .nodeUpdate(v)? = kind { return v }
                return PB_PathEvent.Update.NodeUpdate()
            }
            set { kind = .nodeUpdate(newValue) }
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        enum OneOf_Kind: Equatable, Sendable {
            case move(PB_PathEvent.Update.Move)
            case nodeCreate(PB_PathEvent.Update.NodeCreate)
            case nodeDelete(PB_PathEvent.Update.NodeDelete)
            case nodeUpdate(PB_PathEvent.Update.NodeUpdate)
        }

        struct Move: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var offset: PB_Vector2 {
                get { _offset ?? PB_Vector2() }
                set { _offset = newValue }
            }

            /// Returns true if `offset` has been explicitly set.
            var hasOffset: Bool { _offset != nil }
            /// Clears the value of `offset`. Subsequent reads from it will return its default value.
            mutating func clearOffset() { _offset = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _offset: PB_Vector2? = nil
        }

        struct NodeCreate: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var prevNodeID: PB_UUID {
                get { _prevNodeID ?? PB_UUID() }
                set { _prevNodeID = newValue }
            }

            /// Returns true if `prevNodeID` has been explicitly set.
            var hasPrevNodeID: Bool { _prevNodeID != nil }
            /// Clears the value of `prevNodeID`. Subsequent reads from it will return its default value.
            mutating func clearPrevNodeID() { _prevNodeID = nil }

            var nodeID: PB_UUID {
                get { _nodeID ?? PB_UUID() }
                set { _nodeID = newValue }
            }

            /// Returns true if `nodeID` has been explicitly set.
            var hasNodeID: Bool { _nodeID != nil }
            /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
            mutating func clearNodeID() { _nodeID = nil }

            var node: PB_PathNode {
                get { _node ?? PB_PathNode() }
                set { _node = newValue }
            }

            /// Returns true if `node` has been explicitly set.
            var hasNode: Bool { _node != nil }
            /// Clears the value of `node`. Subsequent reads from it will return its default value.
            mutating func clearNode() { _node = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _prevNodeID: PB_UUID? = nil
            fileprivate var _nodeID: PB_UUID? = nil
            fileprivate var _node: PB_PathNode? = nil
        }

        struct NodeDelete: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var nodeID: PB_UUID {
                get { _nodeID ?? PB_UUID() }
                set { _nodeID = newValue }
            }

            /// Returns true if `nodeID` has been explicitly set.
            var hasNodeID: Bool { _nodeID != nil }
            /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
            mutating func clearNodeID() { _nodeID = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _nodeID: PB_UUID? = nil
        }

        struct NodeUpdate: Sendable {
            // SwiftProtobuf.Message conformance is added in an extension below. See the
            // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
            // methods supported on all messages.

            var nodeID: PB_UUID {
                get { _nodeID ?? PB_UUID() }
                set { _nodeID = newValue }
            }

            /// Returns true if `nodeID` has been explicitly set.
            var hasNodeID: Bool { _nodeID != nil }
            /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
            mutating func clearNodeID() { _nodeID = nil }

            var node: PB_PathNode {
                get { _node ?? PB_PathNode() }
                set { _node = newValue }
            }

            /// Returns true if `node` has been explicitly set.
            var hasNode: Bool { _node != nil }
            /// Clears the value of `node`. Subsequent reads from it will return its default value.
            mutating func clearNode() { _node = nil }

            var unknownFields = SwiftProtobuf.UnknownStorage()

            init() {}

            fileprivate var _nodeID: PB_UUID? = nil
            fileprivate var _node: PB_PathNode? = nil
        }

        init() {}

        fileprivate var _pathID: PB_UUID? = nil
    }

    init() {}
}

struct PB_DocumentEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: PB_UUID {
        get { _id ?? PB_UUID() }
        set { _id = newValue }
    }

    /// Returns true if `id` has been explicitly set.
    var hasID: Bool { _id != nil }
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() { _id = nil }

    var time: SwiftProtobuf.Google_Protobuf_Timestamp {
        get { _time ?? SwiftProtobuf.Google_Protobuf_Timestamp() }
        set { _time = newValue }
    }

    /// Returns true if `time` has been explicitly set.
    var hasTime: Bool { _time != nil }
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    mutating func clearTime() { _time = nil }

    var kind: PB_DocumentEvent.OneOf_Kind? = nil

    var pathEvent: PB_PathEvent {
        get {
            if case let .pathEvent(v)? = kind { return v }
            return PB_PathEvent()
        }
        set { kind = .pathEvent(newValue) }
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Kind: Equatable, Sendable {
        case pathEvent(PB_PathEvent)
    }

    init() {}

    fileprivate var _id: PB_UUID? = nil
    fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "PB"

extension PB_UUID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".UUID"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "data"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &data)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_UUID, rhs: PB_UUID) -> Bool {
        if lhs.data != rhs.data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_Vector2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Vector2"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "x"),
        2: .same(proto: "y"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularFloatField(value: &x)
            case 2: try decoder.decodeSingularFloatField(value: &y)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if x.bitPattern != 0 {
            try visitor.visitSingularFloatField(value: x, fieldNumber: 1)
        }
        if y.bitPattern != 0 {
            try visitor.visitSingularFloatField(value: y, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_Vector2, rhs: PB_Vector2) -> Bool {
        if lhs.x != rhs.x { return false }
        if lhs.y != rhs.y { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_PathNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PathNode"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "position"),
        2: .standard(proto: "cubic_in"),
        3: .standard(proto: "cubic_out"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_position)
            case 2: try decoder.decodeSingularMessageField(value: &_cubicIn)
            case 3: try decoder.decodeSingularMessageField(value: &_cubicOut)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._position {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._cubicIn {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._cubicOut {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_PathNode, rhs: PB_PathNode) -> Bool {
        if lhs._position != rhs._position { return false }
        if lhs._cubicIn != rhs._cubicIn { return false }
        if lhs._cubicOut != rhs._cubicOut { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_Path: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".Path"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "node_ids"),
        2: .same(proto: "nodes"),
        3: .standard(proto: "is_closed"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeRepeatedMessageField(value: &nodeIds)
            case 2: try decoder.decodeRepeatedMessageField(value: &nodes)
            case 3: try decoder.decodeSingularBoolField(value: &isClosed)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        if !nodeIds.isEmpty {
            try visitor.visitRepeatedMessageField(value: nodeIds, fieldNumber: 1)
        }
        if !nodes.isEmpty {
            try visitor.visitRepeatedMessageField(value: nodes, fieldNumber: 2)
        }
        if isClosed != false {
            try visitor.visitSingularBoolField(value: isClosed, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_Path, rhs: PB_Path) -> Bool {
        if lhs.nodeIds != rhs.nodeIds { return false }
        if lhs.nodes != rhs.nodes { return false }
        if lhs.isClosed != rhs.isClosed { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_PathEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".PathEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        101: .same(proto: "create"),
        102: .same(proto: "delete"),
        103: .same(proto: "update"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 101: try {
                    var v: PB_PathEvent.Create?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .create(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .create(v)
                    }
                }()
            case 102: try {
                    var v: PB_PathEvent.Delete?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .delete(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .delete(v)
                    }
                }()
            case 103: try {
                    var v: PB_PathEvent.Update?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .update(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .update(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        switch kind {
        case .create?: try {
                guard case let .create(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
            }()
        case .delete?: try {
                guard case let .delete(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
            }()
        case .update?: try {
                guard case let .update(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_PathEvent, rhs: PB_PathEvent) -> Bool {
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_PathEvent.Create: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = PB_PathEvent.protoMessageName + ".Create"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "path_id"),
        2: .same(proto: "path"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_pathID)
            case 2: try decoder.decodeSingularMessageField(value: &_path)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._pathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._path {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_PathEvent.Create, rhs: PB_PathEvent.Create) -> Bool {
        if lhs._pathID != rhs._pathID { return false }
        if lhs._path != rhs._path { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_PathEvent.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = PB_PathEvent.protoMessageName + ".Delete"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "path_id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_pathID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._pathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_PathEvent.Delete, rhs: PB_PathEvent.Delete) -> Bool {
        if lhs._pathID != rhs._pathID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_PathEvent.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = PB_PathEvent.protoMessageName + ".Update"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "path_id"),
        101: .same(proto: "move"),
        102: .standard(proto: "node_create"),
        103: .standard(proto: "node_delete"),
        104: .standard(proto: "node_update"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_pathID)
            case 101: try {
                    var v: PB_PathEvent.Update.Move?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .move(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .move(v)
                    }
                }()
            case 102: try {
                    var v: PB_PathEvent.Update.NodeCreate?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .nodeCreate(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .nodeCreate(v)
                    }
                }()
            case 103: try {
                    var v: PB_PathEvent.Update.NodeDelete?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .nodeDelete(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .nodeDelete(v)
                    }
                }()
            case 104: try {
                    var v: PB_PathEvent.Update.NodeUpdate?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .nodeUpdate(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .nodeUpdate(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._pathID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        switch kind {
        case .move?: try {
                guard case let .move(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
            }()
        case .nodeCreate?: try {
                guard case let .nodeCreate(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
            }()
        case .nodeDelete?: try {
                guard case let .nodeDelete(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
            }()
        case .nodeUpdate?: try {
                guard case let .nodeUpdate(v)? = self.kind else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_PathEvent.Update, rhs: PB_PathEvent.Update) -> Bool {
        if lhs._pathID != rhs._pathID { return false }
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_PathEvent.Update.Move: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = PB_PathEvent.Update.protoMessageName + ".Move"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "offset"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_offset)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._offset {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_PathEvent.Update.Move, rhs: PB_PathEvent.Update.Move) -> Bool {
        if lhs._offset != rhs._offset { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_PathEvent.Update.NodeCreate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = PB_PathEvent.Update.protoMessageName + ".NodeCreate"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "prev_node_id"),
        2: .standard(proto: "node_id"),
        3: .same(proto: "node"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_prevNodeID)
            case 2: try decoder.decodeSingularMessageField(value: &_nodeID)
            case 3: try decoder.decodeSingularMessageField(value: &_node)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._prevNodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._nodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._node {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_PathEvent.Update.NodeCreate, rhs: PB_PathEvent.Update.NodeCreate) -> Bool {
        if lhs._prevNodeID != rhs._prevNodeID { return false }
        if lhs._nodeID != rhs._nodeID { return false }
        if lhs._node != rhs._node { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_PathEvent.Update.NodeDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = PB_PathEvent.Update.protoMessageName + ".NodeDelete"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "node_id"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_nodeID)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._nodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_PathEvent.Update.NodeDelete, rhs: PB_PathEvent.Update.NodeDelete) -> Bool {
        if lhs._nodeID != rhs._nodeID { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_PathEvent.Update.NodeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = PB_PathEvent.Update.protoMessageName + ".NodeUpdate"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "node_id"),
        2: .same(proto: "node"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_nodeID)
            case 2: try decoder.decodeSingularMessageField(value: &_node)
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._nodeID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._node {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_PathEvent.Update.NodeUpdate, rhs: PB_PathEvent.Update.NodeUpdate) -> Bool {
        if lhs._nodeID != rhs._nodeID { return false }
        if lhs._node != rhs._node { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension PB_DocumentEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = _protobuf_package + ".DocumentEvent"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
        2: .same(proto: "time"),
        101: .standard(proto: "path_event"),
    ]

    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_id)
            case 2: try decoder.decodeSingularMessageField(value: &_time)
            case 101: try {
                    var v: PB_PathEvent?
                    var hadOneofValue = false
                    if let current = self.kind {
                        hadOneofValue = true
                        if case let .pathEvent(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v = v {
                        if hadOneofValue { try decoder.handleConflictingOneOf() }
                        self.kind = .pathEvent(v)
                    }
                }()
            default: break
            }
        }
    }

    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._id {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._time {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        } }()
        try { if case let .pathEvent(v)? = self.kind {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: PB_DocumentEvent, rhs: PB_DocumentEvent) -> Bool {
        if lhs._id != rhs._id { return false }
        if lhs._time != rhs._time { return false }
        if lhs.kind != rhs.kind { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
